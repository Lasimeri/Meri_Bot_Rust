// Meri Bot - A Discord bot with AI capabilities and context persistence
// Main entry point for the bot application

// ============================================================================
// MODULE DECLARATIONS
// ============================================================================

mod commands;           // All command modules (see src/commands/)

// ============================================================================
// IMPORTS
// ============================================================================

// Discord bot framework imports
use serenity::{
    async_trait,
    client::{Client, Context, EventHandler},
    framework::standard::{StandardFramework, Args, Delimiter},
    model::gateway::Ready,
    model::channel::Message,
    model::id::UserId,
    model::application::interaction::Interaction,
    model::guild::Guild,
    prelude::GatewayIntents,
    prelude::TypeMapKey,
};

// Standard library imports
use std::{
    env,                    // Environment variable management
    fs,                     // File system operations
    collections::HashMap,   // Hash map for data storage
    path::Path,             // Path handling
    io::Write,              // I/O writing operations
};

// Async runtime imports
use tokio::{
    signal,               // Signal handling (Ctrl+C, etc.)
    sync::mpsc,           // Multi-producer, single-consumer channels
};

// Serialization and time imports
use serde::{Serialize, Deserialize}; // Serialization for data persistence
use chrono::{DateTime, Utc};         // Date/time handling

// Local imports
use crate::commands::search::ChatMessage;  // Chat message structure for context

// Command imports (auto-generated by Serenity)
// Commands are auto-registered by the #[command] macro

// Slash command imports
use crate::commands::slash::{handle_slash_command, register_slash_commands};

// ============================================================================
// DATA STRUCTURES
// ============================================================================

/// Enhanced context structure with 50/50 balance and persistence
/// This maintains conversation history for each user with automatic balancing
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserContext {
    pub user_messages: Vec<ChatMessage>,      // Messages sent by the user
    pub assistant_messages: Vec<ChatMessage>, // Messages sent by the bot
    pub last_updated: DateTime<Utc>,          // Timestamp of last interaction
    pub total_interactions: usize,            // Total number of interactions
}

impl UserContext {
    /// Create a new empty user context
    pub fn new() -> Self {
        Self {
            user_messages: Vec::new(),
            assistant_messages: Vec::new(),
            last_updated: Utc::now(),
            total_interactions: 0,
        }
    }

    /// Add a user message to the context and maintain balance
    pub fn add_user_message(&mut self, message: ChatMessage) {
        // Check if we're about to exceed the limit
        if self.user_messages.len() >= 250 {
            println!("[CONTEXT] User context full ({} messages), removing oldest user message", self.user_messages.len());
            self.user_messages.remove(0); // Remove the oldest message
        }
        
        self.user_messages.push(message);
        self.last_updated = Utc::now();
        self.total_interactions += 1;
        
        println!("[CONTEXT] Added user message. Total: {} user, {} assistant messages", 
            self.user_messages.len(), self.assistant_messages.len());
    }

    /// Add an assistant message to the context and maintain balance
    pub fn add_assistant_message(&mut self, message: ChatMessage) {
        // Check if we're about to exceed the limit
        if self.assistant_messages.len() >= 250 {
            println!("[CONTEXT] Assistant context full ({} messages), removing oldest assistant message", self.assistant_messages.len());
            self.assistant_messages.remove(0); // Remove the oldest message
        }
        
        self.assistant_messages.push(message);
        self.last_updated = Utc::now();
        
        println!("[CONTEXT] Added assistant message. Total: {} user, {} assistant messages", 
            self.user_messages.len(), self.assistant_messages.len());
    }

    /// Get all conversation messages in chronological order
    /// This interleaves user and assistant messages for proper context
    pub fn get_conversation_messages(&self) -> Vec<ChatMessage> {
        let mut messages = Vec::new();
        let user_len = self.user_messages.len();
        let assistant_len = self.assistant_messages.len();
        let max_len = std::cmp::max(user_len, assistant_len);

        for i in 0..max_len {
            if i < user_len {
                messages.push(self.user_messages[i].clone());
            }
            if i < assistant_len {
                messages.push(self.assistant_messages[i].clone());
            }
        }

        messages
    }

    /// Maintain 50/50 balance between user and assistant messages
    /// This prevents context from becoming too one-sided
    fn maintain_balance(&mut self) {
        // Keep only the last 250 messages of each type
        if self.user_messages.len() > 250 {
            let removed = self.user_messages.len() - 250;
            println!("[CONTEXT] Removing {} oldest user messages to maintain balance", removed);
            self.user_messages.drain(0..removed);
        }
        if self.assistant_messages.len() > 250 {
            let removed = self.assistant_messages.len() - 250;
            println!("[CONTEXT] Removing {} oldest assistant messages to maintain balance", removed);
            self.assistant_messages.drain(0..removed);
        }
    }

    /// Check if context is getting too large and needs cleanup
    pub fn needs_cleanup(&self) -> bool {
        self.user_messages.len() > 225 || self.assistant_messages.len() > 225
    }

    /// Get context size information for debugging
    pub fn get_context_info(&self) -> String {
        format!("User: {} messages, Assistant: {} messages, Total: {} messages", 
            self.user_messages.len(), self.assistant_messages.len(), self.total_messages())
    }

    /// Clear all conversation history
    pub fn clear(&mut self) {
        self.user_messages.clear();
        self.assistant_messages.clear();
        self.last_updated = Utc::now();
    }

    /// Get total number of messages in context
    pub fn total_messages(&self) -> usize {
        self.user_messages.len() + self.assistant_messages.len()
    }

    /// Force cleanup of context to ensure it stays within limits
    /// This is a safety method to prevent context overflow
    pub fn force_cleanup(&mut self) {
        let user_removed = if self.user_messages.len() > 250 {
            let removed = self.user_messages.len() - 250;
            println!("[CONTEXT] Force cleanup: Removing {} oldest user messages", removed);
            self.user_messages.drain(0..removed);
            removed
        } else {
            0
        };
        
        let assistant_removed = if self.assistant_messages.len() > 250 {
            let removed = self.assistant_messages.len() - 250;
            println!("[CONTEXT] Force cleanup: Removing {} oldest assistant messages", removed);
            self.assistant_messages.drain(0..removed);
            removed
        } else {
            0
        };
        
        if user_removed > 0 || assistant_removed > 0 {
            println!("[CONTEXT] Force cleanup completed: removed {} user, {} assistant messages", user_removed, assistant_removed);
        }
    }
}

// ============================================================================
// TYPEMAP KEYS
// ============================================================================

/// TypeMap key for LM chat context - stores conversation history for language model
pub struct LmContextMap;
impl TypeMapKey for LmContextMap {
    type Value = HashMap<UserId, UserContext>;
}

/// TypeMap key for Reason chat context - stores conversation history for reasoning
pub struct ReasonContextMap;
impl TypeMapKey for ReasonContextMap {
    type Value = HashMap<UserId, UserContext>;
}

/// TypeMap key for storing user conversation histories to enable context-aware queries about other users' conversations
pub struct UserConversationHistoryMap;
impl TypeMapKey for UserConversationHistoryMap {
    type Value = HashMap<UserId, Vec<ChatMessage>>;
}

/// TypeMap key for global LM chat context - stores conversation history shared across all users
/// Used when the bot is mentioned (not for ^lm command)
pub struct GlobalLmContextMap;
impl TypeMapKey for GlobalLmContextMap {
    type Value = UserContext;
}

// ============================================================================
// COMMAND GROUP
// ============================================================================

// Commands are auto-registered by the #[command] macro

// ============================================================================
// TEXT FILE PROCESSING HELPERS
// ============================================================================

/// Read a text file into a String, removing BOM if present
/// Returns Ok(String) or Err(String) with error message
fn read_text_file(path: &str) -> Result<String, String> {
    match fs::read_to_string(path) {
        Ok(content) => {
            // Remove BOM if present (Windows text file encoding)
            let content = content.strip_prefix('\u{feff}').unwrap_or(&content);
            Ok(content.to_string())
        },
        Err(e) => Err(format!("Failed to read file '{}': {}", path, e)),
    }
}

// ============================================================================
// CONFIGURATION MANAGEMENT
// ============================================================================

/// Load server blacklist from server_blacklist.txt file
/// Returns a HashSet of server IDs that the bot should not join
fn load_server_blacklist() -> std::collections::HashSet<u64> {
    let blacklist_paths = [
        "server_blacklist.txt",           // Current directory
        "../server_blacklist.txt",        // Parent directory
        "../../server_blacklist.txt",     // Grandparent directory
        "src/server_blacklist.txt"        // Source directory
    ];
    
    for blacklist_path in &blacklist_paths {
        match read_text_file(blacklist_path) {
            Ok(content) => {
                let mut blacklist = std::collections::HashSet::new();
                for line in content.lines() {
                    let line = line.trim();
                    // Skip empty lines and comments
                    if line.is_empty() || line.starts_with('#') {
                        continue;
                    }
                    // Parse server ID
                    if let Ok(server_id) = line.parse::<u64>() {
                        blacklist.insert(server_id);
                    }
                }
                println!("Server blacklist loaded from {} with {} entries", blacklist_path, blacklist.len());
                return blacklist;
            }
            Err(_) => {
                // Try next path
                continue;
            }
        }
    }
    
    println!("No server_blacklist.txt file found, using empty blacklist");
    std::collections::HashSet::new()
}

/// Load bot configuration from botconfig.txt file with multi-path fallback
/// This searches multiple locations for the configuration file
fn load_bot_config() -> Result<HashMap<String, String>, String> {
    let config_paths = [
        "botconfig.txt",           // Current directory
        "../botconfig.txt",        // Parent directory
        "../../botconfig.txt",     // Grandparent directory
        "src/botconfig.txt"        // Source directory
    ];
    
    // Clear any existing relevant environment variables
    env::remove_var("DISCORD_TOKEN");
    env::remove_var("PREFIX");
    env::remove_var("RUST_LOG");
    
    // Try each possible config file location
    for config_path in &config_paths {
        match read_text_file(config_path) {
            Ok(content) => {
                let mut config = HashMap::new();
                // Parse the config file line by line
                for line in content.lines() {
                    let line = line.trim();
                    // Skip empty lines and comments
                    if line.is_empty() || line.starts_with('#') {
                        continue;
                    }
                    // Parse KEY=VALUE format
                    if let Some(equals_pos) = line.find('=') {
                        let key = line[..equals_pos].trim().to_string();
                        let value = line[equals_pos + 1..].trim().to_string();
                        // Set environment variable for compatibility
                        env::set_var(&key, &value);
                        config.insert(key, value);
                    }
                }
                println!("Configuration loaded from {}", config_path);
                return Ok(config);
            }
            Err(_) => {
                // Try next path
                continue;
            }
        }
    }
    Err("No botconfig.txt file found in any expected location (., .., ../.., src/)".to_string())
}

/// Validate Discord token from configuration and log details
fn validate_discord_token() -> Result<String, String> {
    match env::var("DISCORD_TOKEN") {
        Ok(token) => {
            let trimmed = token.trim();
            // Log partial token for debugging (never full token)
            if trimmed.len() >= 12 {
                log::info!("Using Discord token: {}...{} ({} chars)", &trimmed[..6], &trimmed[trimmed.len()-6..], trimmed.len());
            } else {
                log::info!("Using Discord token: {} ({} chars)", trimmed, trimmed.len());
            }
            // Warn if token is surrounded by quotes or whitespace
            if token != trimmed {
                log::warn!("Discord token has leading/trailing whitespace or quotes. It will be trimmed.");
            }
            // Validate token is not placeholder
            if trimmed == "YOUR_BOT_TOKEN_HERE" || trimmed.is_empty() {
                log::error!("DISCORD_TOKEN in botconfig.txt is set to placeholder value or is empty");
                return Err("DISCORD_TOKEN in botconfig.txt is set to placeholder value or is empty".to_string());
            }
            Ok(trimmed.to_string())
        }
        Err(_) => {
            log::error!("DISCORD_TOKEN not found in botconfig.txt file");
            Err("DISCORD_TOKEN not found in botconfig.txt file".to_string())
        }
    }
}

// ============================================================================
// CONTEXT PERSISTENCE
// ============================================================================

/// Save all user contexts to disk for persistence across bot restarts
pub async fn save_contexts_to_disk(
    lm_contexts: &HashMap<UserId, UserContext>,
    reason_contexts: &HashMap<UserId, UserContext>,
    global_lm_context: &UserContext,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    // Create contexts directory if it doesn't exist
    let contexts_dir = Path::new("contexts");
    if !contexts_dir.exists() {
        std::fs::create_dir_all(contexts_dir)?;
    }

    // Save LM contexts (language model conversation history)
    let lm_file = contexts_dir.join("lm_contexts.json");
    let lm_json = serde_json::to_string_pretty(lm_contexts)?;
    let mut lm_file_handle = std::fs::File::create(&lm_file)?;
    lm_file_handle.write_all(lm_json.as_bytes())?;

    // Save Reason contexts (reasoning conversation history)
    let reason_file = contexts_dir.join("reason_contexts.json");
    let reason_json = serde_json::to_string_pretty(reason_contexts)?;
    let mut reason_file_handle = std::fs::File::create(&reason_file)?;
    reason_file_handle.write_all(reason_json.as_bytes())?;

    // Save global LM context (shared across all users)
    let global_lm_file = contexts_dir.join("global_lm_context.json");
    let global_lm_json = serde_json::to_string_pretty(global_lm_context)?;
    let mut global_lm_file_handle = std::fs::File::create(&global_lm_file)?;
    global_lm_file_handle.write_all(global_lm_json.as_bytes())?;

    println!("Saved {} LM contexts, {} Reason contexts, and 1 global LM context to disk", 
        lm_contexts.len(), reason_contexts.len());
    Ok(())
}

/// Load all user contexts from disk on bot startup
pub async fn load_contexts_from_disk() -> Result<(HashMap<UserId, UserContext>, HashMap<UserId, UserContext>, UserContext), Box<dyn std::error::Error + Send + Sync>> {
    let contexts_dir = Path::new("contexts");
    
    // Load LM contexts (language model conversation history)
    let lm_file = contexts_dir.join("lm_contexts.json");
    let lm_contexts = if lm_file.exists() {
        let lm_content = std::fs::read_to_string(&lm_file)?;
        serde_json::from_str::<HashMap<UserId, UserContext>>(&lm_content)?
    } else {
        HashMap::new()
    };

    // Load Reason contexts (reasoning conversation history)
    let reason_file = contexts_dir.join("reason_contexts.json");
    let reason_contexts = if reason_file.exists() {
        let reason_content = std::fs::read_to_string(&reason_file)?;
        serde_json::from_str::<HashMap<UserId, UserContext>>(&reason_content)?
    } else {
        HashMap::new()
    };

    // Load global LM context (shared across all users)
    let global_lm_file = contexts_dir.join("global_lm_context.json");
    let global_lm_context = if global_lm_file.exists() {
        let global_lm_content = std::fs::read_to_string(&global_lm_file)?;
        serde_json::from_str::<UserContext>(&global_lm_content)?
    } else {
        UserContext::new()
    };

    println!("Loaded {} LM contexts, {} Reason contexts, and 1 global LM context from disk", 
        lm_contexts.len(), reason_contexts.len());
    
    Ok((lm_contexts, reason_contexts, global_lm_context))
}

// ============================================================================
// GLOBAL STATE
// ============================================================================

use std::sync::atomic::AtomicBool;
use std::sync::Mutex;


/// Global flag to track if the bot has successfully connected to Discord
static BOT_CONNECTED: AtomicBool = AtomicBool::new(false);

/// Global Discord HTTP client reference for admin commands
static DISCORD_HTTP: Mutex<Option<std::sync::Arc<serenity::http::Http>>> = Mutex::new(None);

/// Global server blacklist
static SERVER_BLACKLIST: Mutex<Option<std::collections::HashSet<u64>>> = Mutex::new(None);

/// Set the global Discord HTTP client reference
pub fn set_discord_http(http: std::sync::Arc<serenity::http::Http>) {
    if let Ok(mut http_guard) = DISCORD_HTTP.lock() {
        *http_guard = Some(http);
    }
}

/// Get the global Discord HTTP client reference
pub fn get_discord_http() -> Option<std::sync::Arc<serenity::http::Http>> {
    if let Ok(http_guard) = DISCORD_HTTP.lock() {
        http_guard.clone()
    } else {
        None
    }
}

/// Set the global server blacklist
pub fn set_server_blacklist(blacklist: std::collections::HashSet<u64>) {
    if let Ok(mut blacklist_guard) = SERVER_BLACKLIST.lock() {
        *blacklist_guard = Some(blacklist);
    }
}

/// Get the global server blacklist
pub fn get_server_blacklist() -> Option<std::collections::HashSet<u64>> {
    if let Ok(mut blacklist_guard) = SERVER_BLACKLIST.lock() {
        blacklist_guard.take()
    } else {
        None
    }
}

/// Check if a server ID is blacklisted
pub fn is_server_blacklisted(server_id: u64) -> bool {
    if let Ok(blacklist_guard) = SERVER_BLACKLIST.lock() {
        if let Some(ref blacklist) = *blacklist_guard {
            blacklist.contains(&server_id)
        } else {
            false
        }
    } else {
        false
    }
}

/// Save the current blacklist to server_blacklist.txt
pub fn save_server_blacklist() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    if let Ok(blacklist_guard) = SERVER_BLACKLIST.lock() {
        if let Some(ref blacklist) = *blacklist_guard {
            let mut content = String::new();
            content.push_str("# Server Blacklist\n");
            content.push_str("# This file contains Discord server IDs that the bot should not join\n");
            content.push_str("# One server ID per line\n");
            content.push_str("# Lines starting with # are comments and will be ignored\n\n");
            
            for server_id in blacklist {
                content.push_str(&format!("{}\n", server_id));
            }
            
            std::fs::write("server_blacklist.txt", content)?;
            println!("✅ Server blacklist saved to server_blacklist.txt");
            Ok(())
        } else {
            Err("Blacklist not initialized".into())
        }
    } else {
        Err("Failed to access blacklist".into())
    }
}

// ============================================================================
// DISCORD EVENT HANDLER
// ============================================================================

/// Event handler implementation - handles Discord events
struct Handler;

#[async_trait]
impl EventHandler for Handler {
    /// Called when the bot successfully connects to Discord
    async fn ready(&self, _: Context, ready: Ready) {
        println!("Bot connected as {}!", ready.user.name);
        
        // Generate and display invite link
        let bot_user_id = env::var("BOT_USER_ID").unwrap_or_else(|_| "1385309017881968761".to_string());
        let application_id = bot_user_id.split('.').next().unwrap_or(&bot_user_id);
        let invite_link = format!("https://discord.com/api/oauth2/authorize?client_id={}&permissions=274877910016&scope=bot", application_id);
        
        println!("🎉 Bot is ready! Invite link:");
        println!("🔗 {}", invite_link);
        println!("📋 Copy this link to invite the bot to your server");
        println!();
        

    }

    /// Handle incoming Discord messages
    /// This is the main message processing logic for the bot
    async fn message(&self, ctx: Context, msg: Message) {
        // Check if this is a user mention (like <@bot_id>)
        let bot_user_id = env::var("BOT_USER_ID").unwrap_or_else(|_| "1385309017881968761".to_string());
        let is_mentioned_by_id = msg.content.contains(&format!("<@{}>", bot_user_id));
        
        // Check if this message is a reply to a bot message
        if let Some(referenced_message) = &msg.referenced_message {
            if referenced_message.author.id.to_string() == bot_user_id {
                // This is a reply to a bot message, ignore it
                return;
            }
        }
        
        // Handle user mentions (for global context)
        if is_mentioned_by_id {
            handle_user_mention(&ctx, &msg, &bot_user_id).await;
        }
        
        // For prefix commands, let the StandardFramework handle them
        // The StandardFramework will automatically process commands like ^lm, ^reason, etc.
        // We don't need to do anything here for prefix commands
    }

    /// Handle Discord interactions (slash commands, buttons, etc.)
    async fn interaction_create(&self, ctx: Context, interaction: Interaction) {
        match interaction {
            Interaction::ApplicationCommand(command_interaction) => {
                // Handle slash commands
                if let Err(e) = handle_slash_command(&ctx, &command_interaction).await {
                    eprintln!("Error handling slash command: {}", e);
                    
                    // Try to send an error message to the user
                    if let Err(_) = command_interaction
                        .create_interaction_response(&ctx.http, |response| {
                            response
                                .kind(serenity::model::application::interaction::InteractionResponseType::ChannelMessageWithSource)
                                .interaction_response_data(|message| {
                                    message.content("❌ An error occurred while processing your command. Please try again.")
                                })
                        })
                        .await
                    {
                        eprintln!("Failed to send error message for slash command");
                    }
                }
            }
            _ => {
                // Handle other interaction types if needed
            }
        }
    }

    /// Handle guild join events (when bot joins a server)
    async fn guild_create(&self, ctx: Context, guild: Guild, _is_new: bool) {
        let guild_id = guild.id.0;
        let guild_name = &guild.name;
        
        // Check if this server is blacklisted
        if is_server_blacklisted(guild_id) {
            println!("🚫 Bot joined blacklisted server: {} ({}) - Leaving immediately", guild_name, guild_id);
            log::warn!("Bot joined blacklisted server: {} ({}) - Leaving immediately", guild_name, guild_id);
            
            // Leave the server immediately
            match guild.id.leave(&ctx.http).await {
                Ok(_) => {
                    println!("✅ Successfully left blacklisted server: {} ({})", guild_name, guild_id);
                    log::info!("Successfully left blacklisted server: {} ({})", guild_name, guild_id);
                }
                Err(e) => {
                    eprintln!("❌ Failed to leave blacklisted server {} ({}): {}", guild_name, guild_id, e);
                    log::error!("Failed to leave blacklisted server {} ({}): {}", guild_name, guild_id, e);
                }
            }
        } else {
            println!("✅ Bot joined server: {} ({})", guild_name, guild_id);
            log::info!("Bot joined server: {} ({})", guild_name, guild_id);
        }
    }
}

/// Handle user ID mentions - functions as ^lm command but with global context
async fn handle_user_mention(ctx: &Context, msg: &Message, bot_user_id: &str) {
    // Log the mention
    log_mention(msg, bot_user_id);
            
    // Extract the prompt after removing the user ID mention
    let prompt = msg.content
        .replace(&format!("<@{}>", bot_user_id), "")
        .trim()
        .to_string();
    
    // Check for special flags that need to be handled by the regular lm command
    if prompt.starts_with("-s ") || prompt.starts_with("--search ") || 
       prompt.starts_with("--test") || prompt == "-t" ||
       prompt.starts_with("--clear") || prompt == "-c" ||
       prompt.starts_with("--clear-global") || prompt == "-cg" {
        // For search, test, and clear commands, use the regular lm command
        // These don't need global context
        let args = Args::new(&prompt, &[Delimiter::Single(' ')]);
        if let Err(e) = crate::commands::lm::lm(ctx, msg, args).await {
            log_error("User mention request failed", &e);
            let _ = msg.reply(ctx, format!("LM error: {}", e)).await;
        } else {
            log_success("User mention request completed successfully");
        }
    } else {
        // For regular chat, vision, and other features, use global context
        if let Err(e) = crate::commands::lm::handle_lm_request_global(ctx, msg, &prompt, Some(&prompt)).await {
            log_error("Global user mention request failed", &e);
            let _ = msg.reply(ctx, format!("LM error: {}", e)).await;
        } else {
            log_success("Global user mention request completed successfully");
        }
    }
}

// ============================================================================
// LOGGING HELPERS
// ============================================================================

/// Log a user mention
fn log_mention(msg: &Message, _bot_user_id: &str) {
    let content = msg.content.clone();
    println!("[MAIN] Bot mentioned via user ID - Raw message content: '{}'", content);
}



/// Log an error
fn log_error(context: &str, error: &dyn std::fmt::Display) {
    let context = context.to_string();
    let error_msg = error.to_string();
    println!("[MAIN] {}: {}", context, error_msg);
}

/// Log a success message
fn log_success(message: &str) {
    let message = message.to_string();
    println!("[MAIN] {}", message);
}



// ============================================================================
// CUSTOM LOG WRITER FOR AGENT LOGS
// ============================================================================

struct AgentLogWriter {
    main_log: std::fs::File,
    agent_log: std::fs::File,
}

impl Write for AgentLogWriter {
    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
        // Write to main log
        self.main_log.write_all(buf)?;
        
        // Check if this is an agent log entry
        let log_entry = String::from_utf8_lossy(buf);
        if log_entry.contains("meri_bot_rust::commands::agent") || log_entry.contains("[AGENT]") {
            // Write to agent log file
            self.agent_log.write_all(buf)?;
            self.agent_log.flush()?;
        }
        
        // Flush main log
        self.main_log.flush()?;
        
        Ok(buf.len())
    }
    
    fn flush(&mut self) -> std::io::Result<()> {
        self.main_log.flush()?;
        self.agent_log.flush()?;
        Ok(())
    }
}

// ============================================================================
// MAIN APPLICATION
// ============================================================================

/// Main application entry point
#[tokio::main]
async fn main() {
    // Enable trace logging for agent module, info for everything else
    std::env::set_var("RUST_LOG", "info,meri_bot_rust::commands::agent=trace");
    
    // Create main log file
    let log_file = std::fs::File::create("log.txt").expect("Failed to create log.txt");
    
    // Create agent log file
    let agent_log_file = std::fs::File::create("agentlog.txt").expect("Failed to create agentlog.txt");
    
    // Initialize custom logger that routes agent logs to separate file
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("info"))
        .format_timestamp_secs()
        .format_module_path(true)
        .format_target(true)
        .write_style(env_logger::WriteStyle::Always)
        .target(env_logger::Target::Pipe(Box::new(AgentLogWriter {
            main_log: log_file,
            agent_log: agent_log_file,
        })))
        .init();
    
    log::info!("=== LOGGING SYSTEM INITIALIZED ===");
    log::info!("Log level: INFO (trace logging enabled for agent module)");
    log::info!("Agent module: TRACE level logging enabled");
    log::info!("Main log file: log.txt");
    log::info!("Agent log file: agentlog.txt");
    log::info!("Console logging: ENABLED");
    log::info!("Module path logging: ENABLED");
    log::info!("Target logging: ENABLED");
    
    // Initialize logging to log.txt for lm.rs
    if let Err(e) = crate::commands::lm::init_logging() {
        log::error!("Failed to initialize lm.rs logging: {}", e);
        eprintln!("❌ Failed to initialize lm.rs logging: {}", e);
        // Continue without lm.rs logging rather than exiting
    } else {
        log::info!("✅ lm.rs logging to log.txt initialized successfully");
        println!("✅ lm.rs logging to log.txt initialized successfully");
    }
    
    // Load configuration from botconfig.txt file
    match load_bot_config() {
        Ok(_) => {
            println!("Configuration loaded from botconfig.txt");
        },
        Err(error) => {
            log::error!("Failed to load botconfig.txt: {}", error);
            eprintln!("Failed to load botconfig.txt: {}", error);
            eprintln!("Create a botconfig.txt file in the project root with: DISCORD_TOKEN=your_token_here and PREFIX=^");
            return;
        }
    };
    
    // Load server blacklist
    let server_blacklist = load_server_blacklist();
    set_server_blacklist(server_blacklist);
    
    // Get and validate Discord token from configuration
    let token = match validate_discord_token() {
        Ok(token) => token,
        Err(error) => {
            log::error!("{}! Replace with your actual Discord bot token.", error);
            eprintln!("{}! Replace with your actual Discord bot token.", error);
            return;
        }
    };
    
    // Get command prefix from configuration
    let prefix = env::var("PREFIX").unwrap_or_else(|_| "^".to_string());
    println!("Starting bot with prefix: '{}'", prefix);
    
    // Set up command framework for Discord bot
    let framework = create_command_framework(&prefix);

    // Configure bot intents (permissions for Discord API)
    let intents = GatewayIntents::non_privileged()
        | GatewayIntents::MESSAGE_CONTENT; // Required for reading message content

    // Set up graceful shutdown
    let (_shutdown_tx, mut shutdown_rx) = mpsc::channel::<String>(1);
    
    // Start the Discord client in the foreground (not a background task)
    println!("Connecting to Discord...");
    log::info!("Starting Discord connection process");
    
    // Log connection attempt details before creating client
    log::info!("Bot token length: {} characters", token.len());
    log::info!("Bot token starts with: {}", &token[..std::cmp::min(10, token.len())]);
    log::info!("Command prefix: '{}'", prefix);
    log::info!("Gateway intents configured: MESSAGE_CONTENT, non_privileged");

    // Create and start Discord client
    log::info!("Creating Discord client with token and intents");
    let mut client = match Client::builder(token.clone(), intents)
        .event_handler(Handler)
        .framework(framework)
        .await
    {
        Ok(client) => {
            log::info!("Discord client created successfully");
            client
        },
        Err(e) => {
            log::error!("Error creating Discord client: {:?}", e);
            eprintln!("Error creating Discord client: {:?}", e);
            eprintln!("Check your token in botconfig.txt file");
            return;
        }
    };

    log::info!("Discord client created, initializing bot data");
    
    // Store the HTTP client globally for admin commands
    set_discord_http(client.cache_and_http.http.clone());
    
    // Initialize context maps
    initialize_bot_data(&mut client).await;
    log::info!("Bot data initialized successfully");

    // Register slash commands with Discord
    log::info!("Registering slash commands with Discord");
    if let Err(e) = register_slash_commands(&client.cache_and_http.http).await {
        log::error!("Failed to register slash commands: {}", e);
        eprintln!("Failed to register slash commands: {}", e);
    } else {
        log::info!("Slash commands registered successfully");
        println!("✅ Slash commands registered with Discord");
    }

    // Check for and update restart messages
    check_and_update_restart_messages(&client).await;

    // Show startup messages
    show_startup_messages().await;

    // Main event loop - wait for shutdown signal or client error
    let shutdown_reason = tokio::select! {
        _ = signal::ctrl_c() => {
            handle_shutdown("SIGINT").await;
            "SIGINT".to_string()
        }
        shutdown_signal = shutdown_rx.recv() => {
            if let Some(signal) = shutdown_signal {
                handle_shutdown(&signal).await;
                signal
            } else {
                "Unknown shutdown".to_string()
            }
        }
        result = client.start() => {
            log::info!("Discord client.start() completed");
            if let Err(why) = result {
                log::error!("Discord client error during connection: {:?}", why);
                eprintln!("Client error: {:?}", why);
                
                // Log specific error details
                let error_str = format!("{:?}", why);
                if error_str.contains("authentication") {
                    log::error!("Authentication error - check if bot token is valid");
                } else if error_str.contains("rate limit") {
                    log::error!("Rate limit error - too many connection attempts");
                } else if error_str.contains("gateway") {
                    log::error!("Gateway error - Discord API issues");
                } else if error_str.contains("network") {
                    log::error!("Network error - check internet connection");
                }
            } else {
                log::info!("Discord client started successfully without errors");
            }
            handle_shutdown("Client task completed").await;
            "Client task completed".to_string()
        }
    };

    // Cleanup and shutdown with context persistence
    println!("Initiating graceful shutdown: {}", shutdown_reason);
    cleanup_and_shutdown(&client).await;
}

/// Create the command framework
fn create_command_framework(prefix: &str) -> StandardFramework {
    StandardFramework::new()
        .configure(|c| {
            c.prefix(prefix)           // Set command prefix
            .case_insensitivity(true)   // Commands are case-insensitive
            .no_dm_prefix(true)         // No prefix needed in DMs
            .with_whitespace(true)      // Allow whitespace in commands
        })
        .after(|_ctx, msg, command_name, result| Box::pin(async move {
            // Post-command execution logging
            match result {
                Ok(()) => {
                    // Command executed successfully
                },
                Err(e) => {
                    log::error!("Command '{}' failed for user {} ({}): {:?}", 
                               command_name, msg.author.name, msg.author.id, e);
                }
            }
        }))
        .unrecognised_command(|_ctx, _msg, _unrecognized_command_name| Box::pin(async move {
            // Handle unrecognized commands (currently silent)
        }))
        // Explicitly register all commands
        .group(&crate::commands::ping::PING_GROUP)
        .group(&crate::commands::echo::ECHO_GROUP)
        .group(&crate::commands::lm::LM_GROUP)
        .group(&crate::commands::reason::REASON_GROUP)
        .group(&crate::commands::agent::AGENT_GROUP)
        .group(&crate::commands::sum::SUM_GROUP)
        .group(&crate::commands::rank::RANK_GROUP)
        .group(&crate::commands::help::HELP_GROUP)
        .group(&crate::commands::admin::ADMIN_GROUP)
}

/// Initialize bot data structures
async fn initialize_bot_data(client: &mut Client) {
        let mut data = client.data.write().await;
        
        // Load existing contexts from disk
        match load_contexts_from_disk().await {
            Ok((lm_contexts, reason_contexts, global_lm_context)) => {
                data.insert::<LmContextMap>(lm_contexts);
                data.insert::<ReasonContextMap>(reason_contexts);
                data.insert::<GlobalLmContextMap>(global_lm_context);
                println!("Context maps initialized with persistent data");
            }
            Err(e) => {
                println!("Failed to load contexts from disk: {}", e);
                println!("Initializing with empty context maps");
                data.insert::<LmContextMap>(HashMap::new());
                data.insert::<ReasonContextMap>(HashMap::new());
                data.insert::<GlobalLmContextMap>(UserContext::new());
            }
        }
        
        data.insert::<UserConversationHistoryMap>(HashMap::new());
}



/// Show startup messages
async fn show_startup_messages() {
    // Generate invite link
    let bot_user_id = env::var("BOT_USER_ID").unwrap_or_else(|_| "1385309017881968761".to_string());
    let application_id = bot_user_id.split('.').next().unwrap_or(&bot_user_id);
    let invite_link = format!("https://discord.com/api/oauth2/authorize?client_id={}&permissions=274877910016&scope=bot", application_id);
    
    println!("Bot is running and connected to Discord!");
    println!("🎉 Bot is ready! Invite link:");
    println!("🔗 {}", invite_link);
    println!("📋 Copy this link to invite the bot to your server");
    println!();
    println!("Slash commands are now available! Try /help to see all commands.");
    println!("Press Ctrl+C to stop gracefully");
}

/// Handle shutdown signals
async fn handle_shutdown(signal: &str) {
    println!("Received '{}' signal, stopping bot gracefully...", signal);
    
    // Note: The actual cleanup is handled in the main function after this returns
    // This function just logs the signal and returns to allow proper cleanup
}

/// Check for and update restart messages from previous bot sessions
async fn check_and_update_restart_messages(client: &Client) {
    // Check if restart message file exists
    if let Ok(restart_info) = std::fs::read_to_string("restart_message.txt") {
        let parts: Vec<&str> = restart_info.split('|').collect();
        if parts.len() == 3 {
            if let (Ok(channel_id), Ok(message_id)) = (parts[0].parse::<u64>(), parts[1].parse::<u64>()) {
                let channel_id = serenity::model::id::ChannelId(channel_id);
                let message_id = serenity::model::id::MessageId(message_id);
                
                // Try to update the restart message
                if let Ok(mut message) = channel_id.message(&client.cache_and_http.http, message_id).await {
                    if let Err(e) = message.edit(&client.cache_and_http.http, |m| {
                        m.content("✅ **Bot Successfully Restarted!**\n\nThe bot has been restarted and is now back online.\n\n🟢 **Status**: Connected and ready")
                    }).await {
                        eprintln!("[RESTART] Failed to update restart message: {}", e);
                    } else {
                        println!("[RESTART] Successfully updated restart message");
                    }
                } else {
                    eprintln!("[RESTART] Could not find restart message to update");
                }
            }
        }
        
        // Clean up the restart message file
        if let Err(e) = std::fs::remove_file("restart_message.txt") {
            eprintln!("[RESTART] Failed to remove restart message file: {}", e);
        }
    }
}

/// Cleanup and shutdown the bot
async fn cleanup_and_shutdown(client: &Client) {
    println!("Shutting down bot...");
    
    // Save contexts to disk before shutting down
    // This preserves conversation history across bot restarts
    {
        let data = client.data.read().await;
        let lm_contexts = data.get::<LmContextMap>().cloned().unwrap_or_default();
        let reason_contexts = data.get::<ReasonContextMap>().cloned().unwrap_or_default();
        let global_lm_context = data.get::<GlobalLmContextMap>().cloned().unwrap_or_else(|| crate::UserContext::new());
        
        println!("Saving conversation contexts to disk...");
        println!("  - LM contexts: {} users", lm_contexts.len());
        println!("  - Reason contexts: {} users", reason_contexts.len());
        println!("  - Global LM context: {} total messages", global_lm_context.total_messages());
        
        if let Err(e) = save_contexts_to_disk(&lm_contexts, &reason_contexts, &global_lm_context).await {
            eprintln!("Failed to save contexts to disk: {}", e);
        } else {
            println!("✅ Contexts saved successfully to disk");
        }
    }
    
    println!("Shutdown complete. Goodbye!");
}
