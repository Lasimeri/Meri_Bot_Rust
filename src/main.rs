mod profilepfp;
mod lm;
mod reason;
mod search;
mod help;
mod ping;
mod echo;
mod sum;

use serenity::{
    async_trait,
    client::{Client, Context, EventHandler},
    framework::standard::{StandardFramework, macros::group},
    model::gateway::Ready,
    prelude::GatewayIntents,
    prelude::TypeMapKey,
};
use std::env;
use std::fs;
use std::collections::HashMap;
use tokio::signal;
use serenity::model::id::UserId;
use crate::search::ChatMessage;

// TypeMap key for LM chat context
pub struct LmContextMap;
impl TypeMapKey for LmContextMap {
    type Value = HashMap<UserId, Vec<ChatMessage>>;
}

// TypeMap key for Reason chat context
pub struct ReasonContextMap;
impl TypeMapKey for ReasonContextMap {
    type Value = HashMap<UserId, Vec<ChatMessage>>;
}

// Import all command constants generated by the #[command] macro
use crate::help::HELP_COMMAND;
use crate::ping::PING_COMMAND;
use crate::echo::ECHO_COMMAND;
use crate::profilepfp::PPFP_COMMAND;
use crate::lm::LM_COMMAND;
use crate::reason::REASON_COMMAND;
use crate::sum::SUM_COMMAND;

// Command group declaration - includes all available commands
#[group]
#[commands(ping, echo, help, ppfp, lm, reason, sum)]
struct General;

// Event handler implementation
struct Handler;

#[async_trait]
impl EventHandler for Handler {
    async fn ready(&self, _: Context, ready: Ready) {
        println!("‚úÖ Bot connected as {}!", ready.user.name);
    }
}

// Function to read configuration from botconfig.txt with multi-path fallback
fn load_bot_config() -> Result<HashMap<String, String>, String> {
    let config_paths = [
        "botconfig.txt",
        "../botconfig.txt", 
        "../../botconfig.txt",
        "src/botconfig.txt"
    ];
    
    // Clear any existing relevant environment variables
    env::remove_var("DISCORD_TOKEN");
    env::remove_var("PREFIX");
    env::remove_var("RUST_LOG");
    
    for config_path in &config_paths {
        match fs::read_to_string(config_path) {
            Ok(content) => {
                // Remove BOM if present
                let content = content.strip_prefix('\u{feff}').unwrap_or(&content);
                let mut config = HashMap::new();
                
                // Parse the config file line by line
                for line in content.lines() {
                    let line = line.trim();
                    
                    // Skip empty lines and comments
                    if line.is_empty() || line.starts_with('#') {
                        continue;
                    }
                    
                    // Parse KEY=VALUE format
                    if let Some(equals_pos) = line.find('=') {
                        let key = line[..equals_pos].trim().to_string();
                        let value = line[equals_pos + 1..].trim().to_string();
                        
                        // Set environment variable for compatibility
                        env::set_var(&key, &value);
                        config.insert(key, value);
                    }
                }
                
                println!("‚úÖ Configuration loaded from {}", config_path);
                return Ok(config);
            }
            Err(_) => {
                // Try next path
                continue;
            }
        }
    }
    
    Err("No botconfig.txt file found in any expected location (., .., ../.., src/)".to_string())
}

#[tokio::main]
async fn main() {
    // Load configuration from botconfig.txt file
    match load_bot_config() {
        Ok(_) => println!("‚úÖ Configuration loaded from botconfig.txt"),
        Err(error) => {
            eprintln!("‚ùå Failed to load botconfig.txt: {}", error);
            eprintln!("Create a botconfig.txt file in the project root with: DISCORD_TOKEN=your_token_here and PREFIX=^");
            return;
        }
    };
    
    // Get Discord token from configuration
    let token = match env::var("DISCORD_TOKEN") {
        Ok(token) => {
            // Validate token is not placeholder
            if token == "YOUR_BOT_TOKEN_HERE" || token.is_empty() {
                eprintln!("‚ùå DISCORD_TOKEN in botconfig.txt is set to placeholder! Replace with your actual Discord bot token.");
                return;
            }
            token
        }
        Err(_) => {
            eprintln!("‚ùå DISCORD_TOKEN not found in botconfig.txt file!");
            return;
        }
    };
    
    // Get command prefix from configuration
    let prefix = env::var("PREFIX").unwrap_or_else(|_| "^".to_string());
    println!("ü§ñ Starting bot with prefix: '{}'", prefix);
    
    // Set up command framework
    let framework = StandardFramework::new()
        .configure(|c| {
            c.prefix(&prefix)
            .case_insensitivity(true)
            .no_dm_prefix(true)
            .with_whitespace(true)
        })
        .after(|_ctx, _msg, command_name, result| Box::pin(async move {
            println!("üîß Command executed: '{}' - Result: {:?}", command_name, result);
        }))
        .unrecognised_command(|_ctx, _msg, unrecognized_command_name| Box::pin(async move {
            println!("‚ùì Unrecognized command attempted: '{}'", unrecognized_command_name);
        }))
        .group(&GENERAL_GROUP);

    // Configure bot intents
    let intents = GatewayIntents::non_privileged()
        | GatewayIntents::MESSAGE_CONTENT;

    // Create and start client
    let mut client = match Client::builder(token, intents)
        .event_handler(Handler)
        .framework(framework)
        .await
    {
        Ok(client) => client,
        Err(e) => {
            eprintln!("‚ùå Error creating Discord client: {:?}", e);
            eprintln!("Check your token in botconfig.txt file");
            return;
        }
    };

    // Initialize per-user context maps for LM and Reason commands
    {
        let mut data = client.data.write().await;
        data.insert::<LmContextMap>(HashMap::new());
        data.insert::<ReasonContextMap>(HashMap::new());
    }

    // Set up graceful shutdown on CTRL+C
    println!("üöÄ Bot is running... Press Ctrl+C to stop");
    tokio::select! {
        _ = signal::ctrl_c() => {
            println!("\n‚èπÔ∏è Stopping bot gracefully...");
        }
        result = client.start() => {
            if let Err(why) = result {
                eprintln!("‚ùå Client error: {:?}", why);
            }
        }
    }
    
    println!("‚úÖ Bot stopped");
}
