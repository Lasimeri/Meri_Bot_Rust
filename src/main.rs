// Meri Bot - A Discord bot with AI capabilities, terminal management, and context persistence
// Main entry point for the bot application

// ============================================================================
// MODULE DECLARATIONS
// ============================================================================

mod commands;           // All command modules (see src/commands/)
mod terminal;           // External command execution and system management
mod terminal_manager;   // Terminal output management and prompt handling

// ============================================================================
// IMPORTS
// ============================================================================

// Discord bot framework imports
use serenity::{
    async_trait,
    client::{Client, Context, EventHandler},
    framework::standard::{StandardFramework, macros::group, Args, Delimiter},
    model::gateway::Ready,
    model::channel::Message,
    model::id::UserId,
    prelude::GatewayIntents,
    prelude::TypeMapKey,
};

// Standard library imports
use std::{
    env,                    // Environment variable management
    fs,                     // File system operations
    collections::HashMap,   // Hash map for data storage
    path::Path,             // Path handling
    io::Write,              // I/O writing operations
};

// Async runtime imports
use tokio::{
    signal,               // Signal handling (Ctrl+C, etc.)
    sync::mpsc,           // Multi-producer, single-consumer channels
    io::{self, AsyncBufReadExt, BufReader}, // Async I/O operations

};

// Serialization and time imports
use serde::{Serialize, Deserialize}; // Serialization for data persistence
use chrono::{DateTime, Utc};         // Date/time handling

// Local imports
use crate::commands::search::ChatMessage;  // Chat message structure for context
use crate::terminal_manager::{TerminalManager, TerminalEvent, get_terminal_manager, set_terminal_manager};

// Command imports (auto-generated by Serenity)
use crate::commands::ping::PING_COMMAND;
use crate::commands::echo::ECHO_COMMAND;
use crate::commands::lm::{LM_COMMAND, CLEARCONTEXT_COMMAND};
use crate::commands::reason::REASON_COMMAND;
use crate::commands::sum::SUM_COMMAND;

// ============================================================================
// DATA STRUCTURES
// ============================================================================

/// Enhanced context structure with 50/50 balance and persistence
/// This maintains conversation history for each user with automatic balancing
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserContext {
    pub user_messages: Vec<ChatMessage>,      // Messages sent by the user
    pub assistant_messages: Vec<ChatMessage>, // Messages sent by the bot
    pub last_updated: DateTime<Utc>,          // Timestamp of last interaction
    pub total_interactions: usize,            // Total number of interactions
}

impl UserContext {
    /// Create a new empty user context
    pub fn new() -> Self {
        Self {
            user_messages: Vec::new(),
            assistant_messages: Vec::new(),
            last_updated: Utc::now(),
            total_interactions: 0,
        }
    }

    /// Add a user message to the context and maintain balance
    pub fn add_user_message(&mut self, message: ChatMessage) {
        // Check if we're about to exceed the limit
        if self.user_messages.len() >= 250 {
            println!("[CONTEXT] User context full ({} messages), removing oldest user message", self.user_messages.len());
            self.user_messages.remove(0); // Remove the oldest message
        }
        
        self.user_messages.push(message);
        self.last_updated = Utc::now();
        self.total_interactions += 1;
        
        println!("[CONTEXT] Added user message. Total: {} user, {} assistant messages", 
            self.user_messages.len(), self.assistant_messages.len());
    }

    /// Add an assistant message to the context and maintain balance
    pub fn add_assistant_message(&mut self, message: ChatMessage) {
        // Check if we're about to exceed the limit
        if self.assistant_messages.len() >= 250 {
            println!("[CONTEXT] Assistant context full ({} messages), removing oldest assistant message", self.assistant_messages.len());
            self.assistant_messages.remove(0); // Remove the oldest message
        }
        
        self.assistant_messages.push(message);
        self.last_updated = Utc::now();
        
        println!("[CONTEXT] Added assistant message. Total: {} user, {} assistant messages", 
            self.user_messages.len(), self.assistant_messages.len());
    }

    /// Get all conversation messages in chronological order
    /// This interleaves user and assistant messages for proper context
    pub fn get_conversation_messages(&self) -> Vec<ChatMessage> {
        let mut messages = Vec::new();
        let user_len = self.user_messages.len();
        let assistant_len = self.assistant_messages.len();
        let max_len = std::cmp::max(user_len, assistant_len);

        for i in 0..max_len {
            if i < user_len {
                messages.push(self.user_messages[i].clone());
            }
            if i < assistant_len {
                messages.push(self.assistant_messages[i].clone());
            }
        }

        messages
    }

    /// Maintain 50/50 balance between user and assistant messages
    /// This prevents context from becoming too one-sided
    fn maintain_balance(&mut self) {
        // Keep only the last 250 messages of each type
        if self.user_messages.len() > 250 {
            let removed = self.user_messages.len() - 250;
            println!("[CONTEXT] Removing {} oldest user messages to maintain balance", removed);
            self.user_messages.drain(0..removed);
        }
        if self.assistant_messages.len() > 250 {
            let removed = self.assistant_messages.len() - 250;
            println!("[CONTEXT] Removing {} oldest assistant messages to maintain balance", removed);
            self.assistant_messages.drain(0..removed);
        }
    }

    /// Check if context is getting too large and needs cleanup
    pub fn needs_cleanup(&self) -> bool {
        self.user_messages.len() > 225 || self.assistant_messages.len() > 225
    }

    /// Get context size information for debugging
    pub fn get_context_info(&self) -> String {
        format!("User: {} messages, Assistant: {} messages, Total: {} messages", 
            self.user_messages.len(), self.assistant_messages.len(), self.total_messages())
    }

    /// Clear all conversation history
    pub fn clear(&mut self) {
        self.user_messages.clear();
        self.assistant_messages.clear();
        self.last_updated = Utc::now();
    }

    /// Get total number of messages in context
    pub fn total_messages(&self) -> usize {
        self.user_messages.len() + self.assistant_messages.len()
    }

    /// Force cleanup of context to ensure it stays within limits
    /// This is a safety method to prevent context overflow
    pub fn force_cleanup(&mut self) {
        let user_removed = if self.user_messages.len() > 250 {
            let removed = self.user_messages.len() - 250;
            println!("[CONTEXT] Force cleanup: Removing {} oldest user messages", removed);
            self.user_messages.drain(0..removed);
            removed
        } else {
            0
        };
        
        let assistant_removed = if self.assistant_messages.len() > 250 {
            let removed = self.assistant_messages.len() - 250;
            println!("[CONTEXT] Force cleanup: Removing {} oldest assistant messages", removed);
            self.assistant_messages.drain(0..removed);
            removed
        } else {
            0
        };
        
        if user_removed > 0 || assistant_removed > 0 {
            println!("[CONTEXT] Force cleanup completed: removed {} user, {} assistant messages", user_removed, assistant_removed);
        }
    }
}

// ============================================================================
// TYPEMAP KEYS
// ============================================================================

/// TypeMap key for LM chat context - stores conversation history for language model
pub struct LmContextMap;
impl TypeMapKey for LmContextMap {
    type Value = HashMap<UserId, UserContext>;
}

/// TypeMap key for Reason chat context - stores conversation history for reasoning
pub struct ReasonContextMap;
impl TypeMapKey for ReasonContextMap {
    type Value = HashMap<UserId, UserContext>;
}

/// TypeMap key for storing user conversation histories to enable context-aware queries about other users' conversations
pub struct UserConversationHistoryMap;
impl TypeMapKey for UserConversationHistoryMap {
    type Value = HashMap<UserId, Vec<ChatMessage>>;
}

// ============================================================================
// COMMAND GROUP
// ============================================================================

/// Command group declaration - includes all available commands
/// This groups commands for the Discord bot framework
#[group]
#[commands(ping, echo, lm, clearcontext, reason, sum)]
struct General;

// ============================================================================
// TEXT FILE PROCESSING HELPERS
// ============================================================================

/// Read a text file into a String, removing BOM if present
/// Returns Ok(String) or Err(String) with error message
fn read_text_file(path: &str) -> Result<String, String> {
    match fs::read_to_string(path) {
        Ok(content) => {
            // Remove BOM if present (Windows text file encoding)
            let content = content.strip_prefix('\u{feff}').unwrap_or(&content);
            Ok(content.to_string())
        },
        Err(e) => Err(format!("Failed to read file '{}': {}", path, e)),
    }
}

// ============================================================================
// CONFIGURATION MANAGEMENT
// ============================================================================

/// Load bot configuration from botconfig.txt file with multi-path fallback
/// This searches multiple locations for the configuration file
fn load_bot_config() -> Result<HashMap<String, String>, String> {
    let config_paths = [
        "botconfig.txt",           // Current directory
        "../botconfig.txt",        // Parent directory
        "../../botconfig.txt",     // Grandparent directory
        "src/botconfig.txt"        // Source directory
    ];
    
    // Clear any existing relevant environment variables
    env::remove_var("DISCORD_TOKEN");
    env::remove_var("PREFIX");
    env::remove_var("RUST_LOG");
    
    // Try each possible config file location
    for config_path in &config_paths {
        match read_text_file(config_path) {
            Ok(content) => {
                let mut config = HashMap::new();
                // Parse the config file line by line
                for line in content.lines() {
                    let line = line.trim();
                    // Skip empty lines and comments
                    if line.is_empty() || line.starts_with('#') {
                        continue;
                    }
                    // Parse KEY=VALUE format
                    if let Some(equals_pos) = line.find('=') {
                        let key = line[..equals_pos].trim().to_string();
                        let value = line[equals_pos + 1..].trim().to_string();
                        // Set environment variable for compatibility
                        env::set_var(&key, &value);
                        config.insert(key, value);
                    }
                }
                println!("Configuration loaded from {}", config_path);
                return Ok(config);
            }
            Err(_) => {
                // Try next path
                continue;
            }
        }
    }
    Err("No botconfig.txt file found in any expected location (., .., ../.., src/)".to_string())
}

/// Validate Discord token from configuration and log details
fn validate_discord_token() -> Result<String, String> {
    match env::var("DISCORD_TOKEN") {
        Ok(token) => {
            let trimmed = token.trim();
            // Log partial token for debugging (never full token)
            if trimmed.len() >= 12 {
                log::info!("Using Discord token: {}...{} ({} chars)", &trimmed[..6], &trimmed[trimmed.len()-6..], trimmed.len());
            } else {
                log::info!("Using Discord token: {} ({} chars)", trimmed, trimmed.len());
            }
            // Warn if token is surrounded by quotes or whitespace
            if token != trimmed {
                log::warn!("Discord token has leading/trailing whitespace or quotes. It will be trimmed.");
            }
            // Validate token is not placeholder
            if trimmed == "YOUR_BOT_TOKEN_HERE" || trimmed.is_empty() {
                log::error!("DISCORD_TOKEN in botconfig.txt is set to placeholder value or is empty");
                return Err("DISCORD_TOKEN in botconfig.txt is set to placeholder value or is empty".to_string());
            }
            Ok(trimmed.to_string())
        }
        Err(_) => {
            log::error!("DISCORD_TOKEN not found in botconfig.txt file");
            Err("DISCORD_TOKEN not found in botconfig.txt file".to_string())
        }
    }
}

// ============================================================================
// CONTEXT PERSISTENCE
// ============================================================================

/// Save all user contexts to disk for persistence across bot restarts
pub async fn save_contexts_to_disk(
    lm_contexts: &HashMap<UserId, UserContext>,
    reason_contexts: &HashMap<UserId, UserContext>,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    // Create contexts directory if it doesn't exist
    let contexts_dir = Path::new("contexts");
    if !contexts_dir.exists() {
        std::fs::create_dir_all(contexts_dir)?;
    }

    // Save LM contexts (language model conversation history)
    let lm_file = contexts_dir.join("lm_contexts.json");
    let lm_json = serde_json::to_string_pretty(lm_contexts)?;
    let mut lm_file_handle = std::fs::File::create(&lm_file)?;
    lm_file_handle.write_all(lm_json.as_bytes())?;

    // Save Reason contexts (reasoning conversation history)
    let reason_file = contexts_dir.join("reason_contexts.json");
    let reason_json = serde_json::to_string_pretty(reason_contexts)?;
    let mut reason_file_handle = std::fs::File::create(&reason_file)?;
    reason_file_handle.write_all(reason_json.as_bytes())?;

    println!("Saved {} LM contexts and {} Reason contexts to disk", 
        lm_contexts.len(), reason_contexts.len());
    Ok(())
}

/// Load all user contexts from disk on bot startup
pub async fn load_contexts_from_disk() -> Result<(HashMap<UserId, UserContext>, HashMap<UserId, UserContext>), Box<dyn std::error::Error + Send + Sync>> {
    let contexts_dir = Path::new("contexts");
    
    // Load LM contexts (language model conversation history)
    let lm_file = contexts_dir.join("lm_contexts.json");
    let lm_contexts = if lm_file.exists() {
        let lm_content = std::fs::read_to_string(&lm_file)?;
        serde_json::from_str::<HashMap<UserId, UserContext>>(&lm_content)?
    } else {
        HashMap::new()
    };

    // Load Reason contexts (reasoning conversation history)
    let reason_file = contexts_dir.join("reason_contexts.json");
    let reason_contexts = if reason_file.exists() {
        let reason_content = std::fs::read_to_string(&reason_file)?;
        serde_json::from_str::<HashMap<UserId, UserContext>>(&reason_content)?
    } else {
        HashMap::new()
    };

    println!("Loaded {} LM contexts and {} Reason contexts from disk", 
        lm_contexts.len(), reason_contexts.len());
    
    Ok((lm_contexts, reason_contexts))
}

// ============================================================================
// GLOBAL STATE
// ============================================================================

use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Mutex;


/// Global flag to track if the bot has successfully connected to Discord
static BOT_CONNECTED: AtomicBool = AtomicBool::new(false);

/// Global terminal child process - can be None if no window is open
static TERMINAL_CHILD: Mutex<Option<tokio::process::Child>> = Mutex::new(None);

// ============================================================================
// DISCORD EVENT HANDLER
// ============================================================================

/// Event handler implementation - handles Discord events
struct Handler;

#[async_trait]
impl EventHandler for Handler {
    /// Called when the bot successfully connects to Discord
    async fn ready(&self, _: Context, ready: Ready) {
        println!("Bot connected as {}!", ready.user.name);
    }

    /// Handle incoming Discord messages
    /// This is the main message processing logic for the bot
    async fn message(&self, ctx: Context, msg: Message) {
        // Only respond to direct user ID mentions (not prefix commands)
        // This allows the bot to be mentioned directly: <@BOT_ID> <message>
        let bot_user_id = env::var("BOT_USER_ID").unwrap_or_else(|_| "1385309017881968761".to_string()); // Configurable bot user ID
        let is_mentioned_by_id = msg.content.contains(&format!("<@{}>", bot_user_id));
        
        if is_mentioned_by_id {
            handle_user_mention(&ctx, &msg, &bot_user_id).await;
        }
    }
}

/// Handle user ID mentions with context-aware processing
async fn handle_user_mention(ctx: &Context, msg: &Message, bot_user_id: &str) {
            let bot_id = ctx.cache.current_user_id();
            
    // Log the mention
    log_mention(msg, bot_user_id);
            
            // Extract the prompt after removing the user ID mention
            let prompt = msg.content
                .replace(&format!("<@{}>", bot_user_id), "")
                .trim()
                .to_string();
                
            // Check if this is a reply to another message (for context-aware responses)
            if let Some(referenced) = &msg.referenced_message {
        handle_reply_mention(ctx, msg, &prompt, referenced, bot_id).await;
    } else {
        handle_direct_mention(ctx, msg, &prompt).await;
    }
}

/// Handle user mentions that are replies to other messages
async fn handle_reply_mention(
    ctx: &Context, 
    msg: &Message, 
    prompt: &str, 
    referenced: &Message, 
    bot_id: serenity::model::id::UserId
) {
                // Check if the referenced message was authored by the bot itself
                // Allow responses to bot's own messages, but add some basic loop prevention
                if referenced.author.id == bot_id {
                    if let Some(manager) = get_terminal_manager() {
                        manager.send_output(format!("[MAIN] User is asking about bot's own message - allowing response with loop prevention"));
                    } else {
                        println!("[MAIN] User is asking about bot's own message - allowing response with loop prevention");
                    }
                    
                    // Basic loop prevention: don't respond if the bot's message was very recent (< 5 seconds)
                    // This prevents rapid back-and-forth but allows legitimate questions about bot responses
                    let message_age = msg.timestamp.timestamp() - referenced.timestamp.timestamp();
                    if message_age < 5 {
                        if let Some(manager) = get_terminal_manager() {
                            manager.send_output(format!("[MAIN] Bot's referenced message is too recent ({} seconds) - preventing potential rapid loop", message_age));
                        } else {
                            println!("[MAIN] Bot's referenced message is too recent ({} seconds) - preventing potential rapid loop", message_age);
                        }
            let _ = msg.reply(ctx, "Please wait a moment before asking about my recent response to avoid loops.").await;
                        return;
                    }
                }
                    
    log_reply_mention(msg, referenced, prompt);
                
                // Check for -v flag - directly invoke lm command for proper handling
                // Vision requests need special handling for attachments
                if prompt.starts_with("-v") || prompt.starts_with("--vision") {
        handle_vision_reply(ctx, msg, prompt).await;
                } else {
                    // RAG-enhanced LM handling for user ID mentions in replies
                    // This provides context-aware responses about specific messages
                    let rag_input = format!(
                        "CONTEXT: The user {} is asking you about a message posted by {}.\n\n\
                        ORIGINAL MESSAGE BY {}:\n\
                        \"{}\"\n\n\
                        USER'S QUESTION ABOUT THIS MESSAGE:\n\
                        \"{}\"\n\n\
                        Please respond to {}'s question specifically about {}'s message above. \
                        Reference the original message content when relevant to provide context and clarity.",
                        msg.author.name,
                        referenced.author.name,
                        referenced.author.name,
                        referenced.content,
                        prompt,
                        msg.author.name,
                        referenced.author.name
                    );
                    
        log_rag_request(msg, referenced, &rag_input);
            
        if let Err(e) = crate::commands::lm::handle_lm_request(ctx, msg, &rag_input, Some(prompt)).await {
            log_error("User ID mention RAG request failed", &e);
            let _ = msg.reply(ctx, format!("LM error: {}", e)).await;
        }
                }
}

/// Handle direct user mentions (not replies)
async fn handle_direct_mention(ctx: &Context, msg: &Message, prompt: &str) {
    log_direct_mention(msg, prompt);
                
                if prompt.is_empty() {
        let _ = msg.reply(ctx, "Please provide a prompt! Usage: `<@Meri_> <your prompt>`\n\nTo ask about a specific message, reply to that message with your question.").await;
                    return;
                }
                
                // Check for -v flag in direct mentions - directly invoke lm command for proper handling
                if prompt.starts_with("-v") || prompt.starts_with("--vision") {
        handle_vision_direct(ctx, msg, prompt).await;
                    } else {
        // Add context for regular direct mentions
        let direct_input = format!(
            "CONTEXT: The user {} is asking you a direct question (not about a specific message).\n\n\
            USER'S QUESTION:\n\
            \"{}\"\n\n\
            Please respond to {}'s question directly.",
            msg.author.name,
            prompt,
            msg.author.name
        );
        
        if let Err(e) = crate::commands::lm::handle_lm_request(ctx, msg, &direct_input, Some(prompt)).await {
            log_error("Direct user ID mention request failed", &e);
            let _ = msg.reply(ctx, format!("LM error: {}", e)).await;
        }
    }
}

/// Handle vision requests in replies
async fn handle_vision_reply(ctx: &Context, msg: &Message, prompt: &str) {
    log_vision_request(msg, "reply");
                    
                    // Create Args from the prompt and call lm command directly
    let args = Args::new(prompt, &[Delimiter::Single(' ')]);
    if let Err(e) = crate::commands::lm::lm(ctx, msg, args).await {
        log_error("Vision request failed", &e);
        let _ = msg.reply(ctx, format!("Vision analysis error: {}", e)).await;
                        } else {
        log_success("Vision request completed successfully");
    }
}

/// Handle vision requests in direct mentions
async fn handle_vision_direct(ctx: &Context, msg: &Message, prompt: &str) {
    log_vision_request(msg, "direct");
    
    // Create Args from the prompt and call lm command directly
    let args = Args::new(prompt, &[Delimiter::Single(' ')]);
    if let Err(e) = crate::commands::lm::lm(ctx, msg, args).await {
        log_error("Vision request failed", &e);
        let _ = msg.reply(ctx, format!("Vision analysis error: {}", e)).await;
                    } else {
        log_success("Vision request completed successfully");
    }
}

// ============================================================================
// LOGGING HELPERS
// ============================================================================

/// Log a user mention
fn log_mention(msg: &Message, _bot_user_id: &str) {
    let content = msg.content.clone();
                        if let Some(manager) = get_terminal_manager() {
        tokio::spawn(async move {
            manager.send_output(format!("[MAIN] Bot mentioned via user ID - Raw message content: '{}'", content)).await;
        });
                        } else {
        println!("[MAIN] Bot mentioned via user ID - Raw message content: '{}'", content);
    }
}

/// Log a reply mention
fn log_reply_mention(_msg: &Message, referenced: &Message, prompt: &str) {
    let author_name = referenced.author.name.clone();
    let prompt = prompt.to_string();
    if let Some(manager) = get_terminal_manager() {
        tokio::spawn(async move {
            manager.send_output(format!("[MAIN] User ID mention used in reply to {}", author_name)).await;
            manager.send_output(format!("[MAIN] Prompt: '{}'", prompt)).await;
        });
                } else {
        println!("[MAIN] User ID mention used in reply to {}", author_name);
        println!("[MAIN] Prompt: '{}'", prompt);
    }
}

/// Log a direct mention
fn log_direct_mention(msg: &Message, prompt: &str) {
    let author_name = msg.author.name.clone();
    let prompt = prompt.to_string();
                        if let Some(manager) = get_terminal_manager() {
        tokio::spawn(async move {
            manager.send_output(format!("[MAIN] Direct user ID mention without reply from user {}", author_name)).await;
            manager.send_output(format!("[MAIN] Prompt: '{}'", prompt)).await;
        });
                        } else {
        println!("[MAIN] Direct user ID mention without reply from user {}", author_name);
        println!("[MAIN] Prompt: '{}'", prompt);
                        }
}

/// Log a vision request
fn log_vision_request(msg: &Message, request_type: &str) {
    let author_name = msg.author.name.clone();
    let request_type = request_type.to_string();
    if let Some(manager) = get_terminal_manager() {
        tokio::spawn(async move {
            manager.send_output(format!("[MAIN] Detected vision request in {} user ID mention", request_type)).await;
            manager.send_output(format!("[MAIN] User {} requesting vision analysis", author_name)).await;
            manager.send_output(format!("[MAIN] Invoking lm command directly for proper {} handling", 
                if request_type == "reply" { "reply and attachment" } else { "attachment" })).await;
        });
    } else {
        println!("[MAIN] Detected vision request in {} user ID mention", request_type);
        println!("[MAIN] User {} requesting vision analysis", author_name);
        println!("[MAIN] Invoking lm command directly for proper {} handling", 
            if request_type == "reply" { "reply and attachment" } else { "attachment" });
    }
}

/// Log a RAG request
fn log_rag_request(msg: &Message, referenced: &Message, rag_input: &str) {
    let msg_author = msg.author.name.clone();
    let ref_author = referenced.author.name.clone();
    let rag_input = rag_input.to_string();
    if let Some(manager) = get_terminal_manager() {
        tokio::spawn(async move {
            manager.send_output("[MAIN] Processing user ID mention RAG request in reply".to_string()).await;
            manager.send_output(format!("[MAIN] User {} asking about message from {}", msg_author, ref_author)).await;
            manager.send_output(format!("[MAIN] RAG input: '{}'", rag_input)).await;
        });
    } else {
        println!("[MAIN] Processing user ID mention RAG request in reply");
        println!("[MAIN] User {} asking about message from {}", msg_author, ref_author);
        println!("[MAIN] RAG input: '{}'", rag_input);
    }
}

/// Log an error
fn log_error(context: &str, error: &dyn std::fmt::Display) {
    let context = context.to_string();
    let error_msg = error.to_string();
    if let Some(manager) = get_terminal_manager() {
        tokio::spawn(async move {
            manager.send_output(format!("[MAIN] {}: {}", context, error_msg)).await;
        });
    } else {
        println!("[MAIN] {}: {}", context, error_msg);
    }
}

/// Log a success message
fn log_success(message: &str) {
    let message = message.to_string();
    if let Some(manager) = get_terminal_manager() {
        tokio::spawn(async move {
            manager.send_output(format!("[MAIN] {}", message)).await;
        });
    } else {
        println!("[MAIN] {}", message);
    }
}

// ============================================================================
// COMMAND LINE INTERFACE
// ============================================================================

/// Handle the command line interface for graceful shutdown and system commands
/// This runs concurrently with the Discord bot and provides local terminal access
async fn handle_command_line(shutdown_tx: mpsc::Sender<String>, event_rx: mpsc::Receiver<TerminalEvent>) {
    use tokio::io::AsyncWriteExt;
    use tokio::time::{sleep, Duration};
    
    let mut event_rx = event_rx;
    let stdin = io::stdin();
    let mut reader = BufReader::new(stdin).lines();
    let mut stdout = io::stdout();
    
    // Wait for bot to connect and show connection messages before showing prompt
    sleep(Duration::from_millis(1500)).await;
    
    // Set prompt as visible and show initial prompt
    if let Some(manager) = get_terminal_manager() {
        *manager.prompt_visible.lock().unwrap() = true;
        manager.show_prompt().await;
        
        // Display initial prompt
        let prompt_text = manager.get_prompt_text();
        if let Err(_) = stdout.write_all(prompt_text.as_bytes()).await {
            eprintln!("Failed to display prompt");
        }
        if let Err(_) = stdout.flush().await {
            eprintln!("Failed to flush stdout");
        }
    }
    
    // Main command processing loop
    loop {
        tokio::select! {
            // Handle terminal events (bot output, prompt management)
            event = event_rx.recv() => {
                handle_terminal_event(event, &mut stdout).await;
            }
            
            // Handle user input
            input = reader.next_line() => {
                if let Ok(Some(line)) = input {
                    let command = line.trim();
                    
                    // Hide prompt before processing command
                    hide_prompt(&mut stdout).await;
                    
                    // Process user commands
                    if let Err(_) = process_user_command(command, &shutdown_tx).await {
                        break;
                    }
                    
                    // Show prompt again after command processing
                    show_prompt(&mut stdout).await;
                } else {
                    // EOF or error reached
                    break;
                }
            }
        }
    }
}

/// Handle terminal events
async fn handle_terminal_event(event: Option<TerminalEvent>, stdout: &mut tokio::io::Stdout) {
    use tokio::io::AsyncWriteExt;
    
    match event {
        Some(TerminalEvent::BotOutput(output)) => {
            // Hide current prompt if visible
            hide_prompt(stdout).await;
                        
                        // Print bot output
                        println!("{}", output);
                        
            // Show prompt again after output
            show_prompt(stdout).await;
                    }
                    Some(TerminalEvent::ShowPrompt) => {
            show_prompt(stdout).await;
                    }
                    Some(TerminalEvent::HidePrompt) => {
            hide_prompt(stdout).await;
        }
        Some(TerminalEvent::UpdatePrompt(new_prompt)) => {
            // Update the prompt text in the manager
                        if let Some(manager) = get_terminal_manager() {
                *manager.prompt_text.lock().unwrap() = new_prompt;
                        }
                    }
                    None => {
                        // Channel closed, exit
                    }
                }
            }
            
/// Show the command prompt
async fn show_prompt(stdout: &mut tokio::io::Stdout) {
    use tokio::io::AsyncWriteExt;
    
    if let Some(manager) = get_terminal_manager() {
        let prompt_text = manager.get_prompt_text();
        if let Err(_) = stdout.write_all(prompt_text.as_bytes()).await {
            eprintln!("Failed to display prompt");
        }
        if let Err(_) = stdout.flush().await {
            eprintln!("Failed to flush stdout");
        }
        *manager.prompt_visible.lock().unwrap() = true;
    }
}

/// Hide the command prompt
async fn hide_prompt(stdout: &mut tokio::io::Stdout) {
    use tokio::io::AsyncWriteExt;
    
                        if let Some(manager) = get_terminal_manager() {
                            if manager.is_prompt_visible() {
            // Clear the current line and hide prompt
                                if let Err(_) = stdout.write_all(b"\r\x1B[K").await {
                                    eprintln!("Failed to clear prompt line");
                                }
                                *manager.prompt_visible.lock().unwrap() = false;
                            }
    }
                        }
                        
/// Process user commands
async fn process_user_command(command: &str, shutdown_tx: &mpsc::Sender<String>) -> Result<(), ()> {
    if command.is_empty() {
        return Ok(());
    }
    match command.to_lowercase().as_str() {
                            "quit" | "q" | "exit" => {
            println!("Shutting down bot...");
                                if let Err(_) = shutdown_tx.send("quit".to_string()).await {
                eprintln!("Failed to send shutdown signal");
                                }
            return Err(()); // Signal to break the loop
                            }
                            "help" | "h" => {
            print_help_message();
                            }
                            "status" => {
            print_status_message();
                            }
                            "new" => {
                                if let Err(e) = terminal::create_terminal_session().await {
                eprintln!("Failed to create new terminal session: {}", e);
                                }
                            }
                            "sysinfo" => {
                                if let Err(e) = terminal::get_system_info().await {
                eprintln!("Failed to get system info: {}", e);
                                }
                            }
                            "processes" => {
                                if let Err(e) = terminal::list_processes().await {
                eprintln!("Failed to list processes: {}", e);
                                }
                            }
                            "disk" => {
                                if let Err(e) = terminal::get_disk_space().await {
                eprintln!("Failed to get disk space: {}", e);
                                }
                            }
                            "network" => {
                                if let Err(e) = terminal::get_network_info().await {
                eprintln!("Failed to get network info: {}", e);
                                }
                            }
                            _ => {
            println!("Unknown or unsupported command: '{}'. Type 'help' for available commands.", command);
                            }
    }
    Ok(())
}

/// Print help message
fn print_help_message() {
    println!("Available bot commands:");
    println!("  help, h        - Show this help message");
    println!("  status         - Show bot status");
    println!("  sysinfo        - Get system information");
    println!("  processes      - List running processes");
    println!("  disk           - Get disk space information");
    println!("  network        - Get network information");
    println!("  new            - Open a new command prompt window");
    println!("  exit, quit     - Stop the bot gracefully");
    println!();
    println!("Only the above bot commands are allowed in this window.");
                    }
                    
/// Print status message
fn print_status_message() {
    println!("Bot Status: Running");
    println!("Discord connection: Active");
    println!("Command interface: Active");
            }

// ============================================================================
// MAIN APPLICATION
// ============================================================================

/// Main application entry point
#[tokio::main]
async fn main() {
    // Enable all log levels for detailed debugging
    std::env::set_var("RUST_LOG", "trace");
    
    // Create log file
    let log_file = std::fs::File::create("log.txt").expect("Failed to create log.txt");
    
    // Initialize logger - must be done before any logging calls
    // Use trace level to show all logs including debug and trace
    // Output to log.txt file
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("trace"))
        .format_timestamp_secs()
        .target(env_logger::Target::Pipe(Box::new(log_file)))
        .init();
    
    // Load configuration from botconfig.txt file
    match load_bot_config() {
        Ok(_) => {
            println!("Configuration loaded from botconfig.txt");
        },
        Err(error) => {
            log::error!("Failed to load botconfig.txt: {}", error);
            eprintln!("Failed to load botconfig.txt: {}", error);
            eprintln!("Create a botconfig.txt file in the project root with: DISCORD_TOKEN=your_token_here and PREFIX=^");
            return;
        }
    };
    
    // Get and validate Discord token from configuration
    let token = match validate_discord_token() {
        Ok(token) => token,
        Err(error) => {
            log::error!("{}! Replace with your actual Discord bot token.", error);
            eprintln!("{}! Replace with your actual Discord bot token.", error);
            return;
        }
    };
    
    // Get command prefix from configuration
    let prefix = env::var("PREFIX").unwrap_or_else(|_| "^".to_string());
    println!("Starting bot with prefix: '{}'", prefix);
    
    // Set up command framework for Discord bot
    let framework = create_command_framework(&prefix);

    // Configure bot intents (permissions for Discord API)
    let intents = GatewayIntents::non_privileged()
        | GatewayIntents::MESSAGE_CONTENT; // Required for reading message content

    // Set up graceful shutdown
    let (shutdown_tx, mut shutdown_rx) = mpsc::channel::<String>(1);
    
    // Initialize terminal management system early (but don't open command window yet)
    let (terminal_manager, event_rx) = TerminalManager::new();
    set_terminal_manager(terminal_manager.clone());
    
    // Start the Discord client in the foreground (not a background task)
    println!("Connecting to Discord...");
    log::info!("Starting Discord connection process");
    
    // Log connection attempt details before creating client
    log::info!("Bot token length: {} characters", token.len());
    log::info!("Bot token starts with: {}", &token[..std::cmp::min(10, token.len())]);
    log::info!("Command prefix: '{}'", prefix);
    log::info!("Gateway intents configured: MESSAGE_CONTENT, non_privileged");

    // Create and start Discord client
    log::info!("Creating Discord client with token and intents");
    let mut client = match Client::builder(token.clone(), intents)
        .event_handler(Handler)
        .framework(framework)
        .await
    {
        Ok(client) => {
            log::info!("Discord client created successfully");
            client
        },
        Err(e) => {
            log::error!("Error creating Discord client: {:?}", e);
            eprintln!("Error creating Discord client: {:?}", e);
            eprintln!("Check your token in botconfig.txt file");
            return;
        }
    };

    log::info!("Discord client created, initializing bot data");
    // Initialize context maps and terminal management
    initialize_bot_data(&mut client).await;
    log::info!("Bot data initialized successfully");

    // Now that bot is connected, set up the command line interface
    let (cmd_task, terminal_child) = setup_command_line_interface(shutdown_tx.clone(), event_rx).await;
    
    // Show startup messages
    show_startup_messages().await;

    // Main event loop - wait for shutdown signal or client error
    tokio::select! {
        _ = signal::ctrl_c() => {
            handle_shutdown("SIGINT").await;
        }
        shutdown_signal = shutdown_rx.recv() => {
            if let Some(signal) = shutdown_signal {
                handle_shutdown(&signal).await;
            }
        }
        result = client.start() => {
            log::info!("Discord client.start() completed");
            if let Err(why) = result {
                log::error!("Discord client error during connection: {:?}", why);
                eprintln!("Client error: {:?}", why);
                
                // Log specific error details
                let error_str = format!("{:?}", why);
                if error_str.contains("authentication") {
                    log::error!("Authentication error - check if bot token is valid");
                } else if error_str.contains("rate limit") {
                    log::error!("Rate limit error - too many connection attempts");
                } else if error_str.contains("gateway") {
                    log::error!("Gateway error - Discord API issues");
                } else if error_str.contains("network") {
                    log::error!("Network error - check internet connection");
                }
            } else {
                log::info!("Discord client started successfully without errors");
            }
            handle_shutdown("Client task completed").await;
        }
    }

    // Cleanup and shutdown
    cleanup_and_shutdown(&client, cmd_task, terminal_child).await;
}

/// Create the command framework
fn create_command_framework(prefix: &str) -> StandardFramework {
    StandardFramework::new()
        .configure(|c| {
            c.prefix(prefix)           // Set command prefix
            .case_insensitivity(true)   // Commands are case-insensitive
            .no_dm_prefix(true)         // No prefix needed in DMs
            .with_whitespace(true)      // Allow whitespace in commands
        })
        .after(|_ctx, msg, command_name, result| Box::pin(async move {
            // Post-command execution logging
            match result {
                Ok(()) => {
                    // Command executed successfully
                },
                Err(e) => {
                    log::error!("Command '{}' failed for user {} ({}): {:?}", 
                               command_name, msg.author.name, msg.author.id, e);
                }
            }
        }))
        .unrecognised_command(|_ctx, _msg, _unrecognized_command_name| Box::pin(async move {
            // Handle unrecognized commands (currently silent)
        }))
        .group(&GENERAL_GROUP)
}

/// Initialize bot data structures
async fn initialize_bot_data(client: &mut Client) {
        let mut data = client.data.write().await;
        
        // Load existing contexts from disk
        match load_contexts_from_disk().await {
            Ok((lm_contexts, reason_contexts)) => {
                data.insert::<LmContextMap>(lm_contexts);
                data.insert::<ReasonContextMap>(reason_contexts);
                println!("Context maps initialized with persistent data");
            }
            Err(e) => {
                println!("Failed to load contexts from disk: {}", e);
                println!("Initializing with empty context maps");
                data.insert::<LmContextMap>(HashMap::new());
                data.insert::<ReasonContextMap>(HashMap::new());
            }
        }
        
        data.insert::<UserConversationHistoryMap>(HashMap::new());
}

/// Set up command line interface
async fn setup_command_line_interface(shutdown_tx: mpsc::Sender<String>, event_rx: mpsc::Receiver<TerminalEvent>) -> (tokio::task::JoinHandle<()>, Option<tokio::process::Child>) {
    // Don't automatically open the command prompt window - it's now optional
    println!("Bot is connected and ready!");
    println!("Type 'cmd' to open the command prompt window, or 'help' for available commands");
    
    // Start a minimal command line handler in background task (for shutdown only)
    let cmd_shutdown_tx = shutdown_tx.clone();
    let cmd_task = tokio::spawn(async move {
        handle_minimal_command_line(cmd_shutdown_tx, event_rx).await;
    });
    (cmd_task, None) // No terminal child initially
}

/// Handle minimal command line interface (shutdown only)
/// This provides a simple way to stop the bot from the main terminal
async fn handle_minimal_command_line(shutdown_tx: mpsc::Sender<String>, event_rx: mpsc::Receiver<TerminalEvent>) {
    use tokio::time::{sleep, Duration};
    
    let mut event_rx = event_rx;
    let stdin = io::stdin();
    let mut reader = BufReader::new(stdin).lines();
    
    // Wait a moment for everything to settle
    sleep(Duration::from_millis(500)).await;
    
    println!("Bot is running and connected to Discord!");
    println!("Type 'cmd' to open the command prompt window");
    println!("Press Ctrl+C or type 'quit' to stop the bot");
    
    // Main command processing loop (minimal - only shutdown commands)
    loop {
    tokio::select! {
            // Handle terminal events (bot output only)
            event = event_rx.recv() => {
                if let Some(TerminalEvent::BotOutput(output)) = event {
                    println!("{}", output);
                }
            }
            
            // Handle user input (only shutdown commands)
            input = reader.next_line() => {
                if let Ok(Some(line)) = input {
                    let command = line.trim().to_lowercase();
                    
                    match command.as_str() {
                        "quit" | "q" | "exit" => {
                            println!("Shutting down bot...");
                            if let Err(_) = shutdown_tx.send("quit".to_string()).await {
                                eprintln!("Failed to send shutdown signal");
                            }
                            // Force exit after sending shutdown signal
                            tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
                            std::process::exit(0);
                        }
                        "cmd" => {
                            println!("Opening command prompt window...");
                            match terminal::create_terminal_session().await {
                                Ok(child) => {
                                    if let Some(child) = child {
                                        // Store the child process globally
                                        if let Ok(mut terminal_guard) = TERMINAL_CHILD.lock() {
                                            *terminal_guard = Some(child);
                                        }
                                        println!("Command prompt window opened successfully!");
                                    } else {
                                        println!("Failed to open command prompt window");
                                    }
                                },
                                Err(e) => {
                                    eprintln!("Failed to open command prompt window: {}", e);
                                }
                            }
                        }
                        "help" | "h" => {
                            println!("Available commands in this terminal:");
                            println!("  cmd            - Open the command prompt window");
                            println!("  quit, q, exit  - Stop the bot gracefully");
                            println!("  help, h        - Show this help message");
                            println!("  status         - Show bot connection status");
                            println!();
                            println!("Use 'cmd' to open a separate command prompt window for system commands");
                        }
                        "status" => {
                            if BOT_CONNECTED.load(Ordering::SeqCst) {
                                println!("Bot Status: Connected to Discord");
            } else {
                                println!("Bot Status: Not connected to Discord");
            }
        }
                        "" => {
                            // Empty line, do nothing
                        }
                        _ => {
                            println!("Unknown command: '{}'. Type 'help' for available commands.", command);
                            println!("Use 'cmd' to open a separate command prompt window for system commands");
                        }
                    }
                } else {
                    // EOF or error reached
                    break;
                }
            }
        }
    }
}

/// Show startup messages
async fn show_startup_messages() {
    if let Some(manager) = get_terminal_manager() {
        manager.send_output("Bot is running and connected to Discord!".to_string()).await;
        manager.send_output("Type 'cmd' to open the command prompt window".to_string()).await;
        manager.send_output("Use 'quit' command or press Ctrl+C to stop gracefully".to_string()).await;
    } else {
        println!("Bot is running and connected to Discord!");
        println!("Type 'cmd' to open the command prompt window");
        println!("Use 'quit' command or press Ctrl+C to stop gracefully");
    }
}

/// Handle shutdown signals
async fn handle_shutdown(signal: &str) {
    println!("Received '{}' signal, stopping bot gracefully...", signal);
    if let Some(manager) = get_terminal_manager() {
        manager.send_output(format!("Received '{}' signal, stopping bot gracefully...", signal)).await;
    }
    
    // Force exit after a short delay to ensure cleanup completes
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    std::process::exit(0);
}

/// Cleanup and shutdown the bot
async fn cleanup_and_shutdown(client: &Client, cmd_task: tokio::task::JoinHandle<()>, _terminal_child: Option<tokio::process::Child>) {
    println!("Shutting down bot and closing all windows...");
    
    // Save contexts to disk before shutting down
    // This preserves conversation history across bot restarts
    {
        let data = client.data.read().await;
        let lm_contexts = data.get::<LmContextMap>().cloned().unwrap_or_default();
        let reason_contexts = data.get::<ReasonContextMap>().cloned().unwrap_or_default();
        
        if let Err(e) = save_contexts_to_disk(&lm_contexts, &reason_contexts).await {
            eprintln!("Failed to save contexts to disk: {}", e);
        }
    }
    
    // Stop the command line task
    cmd_task.abort();
    
    // Close the command prompt window if it exists (from global state)
    if let Ok(mut terminal_guard) = TERMINAL_CHILD.lock() {
        if let Some(mut child) = terminal_guard.take() {
            println!("Closing command prompt window...");
            if let Err(e) = child.kill().await {
                eprintln!("Failed to kill terminal process: {}", e);
            }
        }
    }
    
    // Also try to close any remaining command prompt windows
    if let Err(e) = terminal::close_bot_command_window().await {
        eprintln!("Failed to close bot command window: {}", e);
    }
    
    // Send final message through terminal manager if available
    if let Some(manager) = get_terminal_manager() {
        manager.send_output("Bot stopped - all windows closed".to_string()).await;
    } else {
        println!("Bot stopped - all windows closed");
    }
    
    println!("Shutdown complete. Goodbye!");
}
