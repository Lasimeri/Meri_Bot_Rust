mod profilepfp;
mod lm;
mod reason;
mod search;
mod help;
mod ping;
mod echo;
mod sum;
mod context;
mod vis;

use serenity::{
    async_trait,
    client::{Client, Context, EventHandler},
    framework::standard::{StandardFramework, macros::group},
    model::gateway::Ready,
    prelude::GatewayIntents,
    prelude::TypeMapKey,
};
use std::env;
use std::fs;
use std::collections::HashMap;
use tokio::signal;
use serenity::model::id::UserId;
use crate::search::ChatMessage;
use serde::{Serialize, Deserialize};
use std::collections::HashSet;
use chrono::{DateTime, Utc};
use serenity::model::channel::Message;

// User profile for cross-context awareness
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserProfile {
    pub user_id: UserId,
    pub username: String,
    pub display_name: Option<String>,
    pub context_summary: String,
    pub interests: Vec<String>,
    pub conversation_style: String,
    pub last_interaction: DateTime<Utc>,
    pub total_messages: u32,
    pub preferred_topics: Vec<String>,
}

// Shared conversation thread
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SharedConversation {
    pub thread_id: String,
    pub participants: HashSet<UserId>,
    pub messages: Vec<ChatMessage>,
    pub topic: String,
    pub created_at: DateTime<Utc>,
    pub last_activity: DateTime<Utc>,
    pub is_active: bool,
}

// User relationships and references
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserRelationships {
    pub user_id: UserId,
    pub mentioned_users: HashSet<UserId>,
    pub conversation_partners: HashSet<UserId>,
    pub shared_topics: Vec<String>,
    pub relationship_notes: HashMap<UserId, String>,
}

// TypeMap key for LM chat context
pub struct LmContextMap;
impl TypeMapKey for LmContextMap {
    type Value = HashMap<UserId, Vec<ChatMessage>>;
}

// TypeMap key for Reason chat context
pub struct ReasonContextMap;
impl TypeMapKey for ReasonContextMap {
    type Value = HashMap<UserId, Vec<ChatMessage>>;
}

// TypeMap key for user profiles and cross-user context
pub struct UserProfileMap;
impl TypeMapKey for UserProfileMap {
    type Value = HashMap<UserId, UserProfile>;
}

// TypeMap key for shared conversation threads
pub struct SharedConversationMap;
impl TypeMapKey for SharedConversationMap {
    type Value = HashMap<String, SharedConversation>;
}

// TypeMap key for user relationships and references
pub struct UserRelationshipMap;
impl TypeMapKey for UserRelationshipMap {
    type Value = HashMap<UserId, UserRelationships>;
}

// TypeMap key for storing user conversation histories to enable context-aware queries about other users' conversations
pub struct UserConversationHistoryMap;
impl TypeMapKey for UserConversationHistoryMap {
    type Value = HashMap<UserId, Vec<ChatMessage>>;
}

// Import all command constants generated by the #[command] macro
use crate::help::HELP_COMMAND;
use crate::ping::PING_COMMAND;
use crate::echo::ECHO_COMMAND;
use crate::profilepfp::PPFP_COMMAND;
use crate::lm::{LM_COMMAND, CLEARCONTEXT_COMMAND};
use crate::reason::REASON_COMMAND;
use crate::sum::SUM_COMMAND;

// Command group declaration - includes all available commands
#[group]
#[commands(ping, echo, help, ppfp, lm, clearcontext, reason, sum)]
struct General;

// Event handler implementation
struct Handler;

#[async_trait]
impl EventHandler for Handler {
    async fn ready(&self, _: Context, ready: Ready) {
        // log::info!("✅ Bot connected as {}! (ID: {})", ready.user.name, ready.user.id);
        // log::info!("📊 Connected to {} guilds", ready.guilds.len());
        println!("✅ Bot connected as {}!", ready.user.name);
    }

    async fn message(&self, ctx: Context, msg: Message) {
        // Only respond to direct user ID mentions
        let bot_user_id = "1385309017881968761";
        let is_mentioned_by_id = msg.content.contains(&format!("<@{}>", bot_user_id));
        
        if is_mentioned_by_id {
            let bot_id = ctx.cache.current_user_id();
            
            println!("[MAIN] Bot mentioned via user ID - Raw message content: '{}'", msg.content);
            
            // Extract the prompt after removing the user ID mention
            let prompt = msg.content
                .replace(&format!("<@{}>", bot_user_id), "")
                .trim()
                .to_string();
                
            // Check if this is a reply to another message
            if let Some(referenced) = &msg.referenced_message {
                // Check if the referenced message was authored by the bot itself
                // Allow responses to bot's own messages, but add some basic loop prevention
                if referenced.author.id == bot_id {
                    println!("[MAIN] User is asking about bot's own message - allowing response with loop prevention");
                    
                    // Basic loop prevention: don't respond if the bot's message was very recent (< 5 seconds)
                    // This prevents rapid back-and-forth but allows legitimate questions about bot responses
                    let message_age = msg.timestamp.timestamp() - referenced.timestamp.timestamp();
                    if message_age < 5 {
                        println!("[MAIN] Bot's referenced message is too recent ({} seconds) - preventing potential rapid loop", message_age);
                        let _ = msg.reply(&ctx, "Please wait a moment before asking about my recent response to avoid loops.").await;
                        return;
                    }
                }
                    
                println!("[MAIN] User ID mention used in reply to {}", referenced.author.name);
                println!("[MAIN] Prompt: '{}'", prompt);
                
                // Check for -v flag - use same attachment handling as lm -v command
                if prompt.starts_with("-v") || prompt.starts_with("--vision") {
                    let vision_prompt = if prompt.starts_with("-v") {
                        let after_flag = if prompt.starts_with("-v ") {
                            &prompt[3..] // "-v "
                        } else {
                            &prompt[2..] // "-v"
                        };
                        after_flag.trim().to_string()
                    } else {
                        let after_flag = if prompt.starts_with("--vision ") {
                            &prompt[9..] // "--vision "
                        } else {
                            &prompt[8..] // "--vision"
                        };
                        after_flag.trim().to_string()
                    };
                    
                    println!("[MAIN] Detected vision request in user ID mention");
                    println!("[MAIN] User {} requesting vision analysis", msg.author.name);
                    println!("[MAIN] Vision prompt: '{}'", vision_prompt);
                    println!("[MAIN] Current message attachments: {}", msg.attachments.len());
                    println!("[MAIN] Referenced message attachments: {}", referenced.attachments.len());
                    
                    // Check for empty prompt (same as lm -v)
                    if vision_prompt.is_empty() {
                        println!("[MAIN] Vision prompt is empty, returning error");
                        let _ = msg.reply(&ctx, "Please provide a prompt for vision analysis! Usage: `^lm -v <prompt>` with image attached.").await;
                        return;
                    }
                    
                    // Check for attachments in current message first, then referenced message (same as lm -v)
                    let attachment_to_process = if !msg.attachments.is_empty() {
                        println!("[MAIN] Found {} attachments in current message", msg.attachments.len());
                        Some(&msg.attachments[0])
                    } else if !referenced.attachments.is_empty() {
                        println!("[MAIN] No local attachments, found {} attachments in referenced message", referenced.attachments.len());
                        Some(&referenced.attachments[0])
                    } else {
                        println!("[MAIN] No attachments found in current or referenced message");
                        None
                    };

                    let attachment = match attachment_to_process {
                        Some(att) => att,
                        None => {
                            println!("[MAIN] No image attachments found in current or referenced message");
                            let _ = msg.reply(&ctx, "Please attach an image for vision analysis, or reply to a message with an image attachment.").await;
                            return;
                        }
                    };

                    let content_type = attachment.content_type.as_deref().unwrap_or("");
                    println!("[MAIN] Found attachment: {} (content_type: {})", attachment.filename, content_type);

                    if !content_type.starts_with("image/") {
                        println!("[MAIN] Attachment is not an image, returning error");
                        let _ = msg.reply(&ctx, "Attached file is not an image. Please attach a valid image file.").await;
                        return;
                    }

                    println!("[MAIN] Calling vis::handle_vision_request...");
                    if let Err(e) = crate::vis::handle_vision_request(&ctx, &msg, &vision_prompt, attachment).await {
                        println!("[MAIN] Vision request failed with error: {}", e);
                        let _ = msg.reply(&ctx, format!("Vision analysis error: {}", e)).await;
                    } else {
                        println!("[MAIN] Vision request completed successfully");
                    }
                } else {
                    // RAG-enhanced LM handling for user ID mentions in replies
                    let rag_input = format!(
                        "CONTEXT: The user {} is asking you about a message posted by {}.\n\n\
                        ORIGINAL MESSAGE BY {}:\n\
                        \"{}\"\n\n\
                        USER'S QUESTION ABOUT THIS MESSAGE:\n\
                        \"{}\"\n\n\
                        Please respond to {}'s question specifically about {}'s message above. \
                        Reference the original message content when relevant to provide context and clarity.",
                        msg.author.name,
                        referenced.author.name,
                        referenced.author.name,
                        referenced.content,
                        prompt,
                        msg.author.name,
                        referenced.author.name
                    );
                    
                    println!("[MAIN] Processing user ID mention RAG request in reply");
                    println!("[MAIN] User {} asking about message from {}", msg.author.name, referenced.author.name);
                    println!("[MAIN] RAG input: '{}'", rag_input);
                        
                    if let Err(e) = lm::handle_lm_request(&ctx, &msg, &rag_input).await {
                        println!("[MAIN] User ID mention RAG request failed: {}", e);
                        let _ = msg.reply(&ctx, format!("LM error: {}", e)).await;
                    }
                }
            } else {
                // Direct user ID mention without reply - treat as regular lm command
                println!("[MAIN] Direct user ID mention without reply from user {}", msg.author.name);
                println!("[MAIN] Prompt: '{}'", prompt);
                
                if prompt.is_empty() {
                    let _ = msg.reply(&ctx, "Please provide a prompt! Usage: `<@Meri_> <your prompt>`\n\nTo ask about a specific message, reply to that message with your question.").await;
                    return;
                }
                
                // Check for -v flag in direct mentions - use same attachment handling as lm -v command
                if prompt.starts_with("-v") || prompt.starts_with("--vision") {
                    let vision_prompt = if prompt.starts_with("-v") {
                        let after_flag = if prompt.starts_with("-v ") {
                            &prompt[3..] // "-v "
                        } else {
                            &prompt[2..] // "-v"
                        };
                        after_flag.trim().to_string()
                    } else {
                        let after_flag = if prompt.starts_with("--vision ") {
                            &prompt[9..] // "--vision "
                        } else {
                            &prompt[8..] // "--vision"
                        };
                        after_flag.trim().to_string()
                    };
                    
                    println!("[MAIN] Detected vision request in direct user ID mention");
                    println!("[MAIN] User {} requesting vision analysis", msg.author.name);
                    println!("[MAIN] Vision prompt: '{}'", vision_prompt);
                    println!("[MAIN] Current message attachments: {}", msg.attachments.len());
                    
                    // Check for empty prompt (same as lm -v)
                    if vision_prompt.is_empty() {
                        println!("[MAIN] Vision prompt is empty, returning error");
                        let _ = msg.reply(&ctx, "Please provide a prompt for vision analysis! Usage: `^lm -v <prompt>` with image attached.").await;
                        return;
                    }
                    
                    // Check for attachments in current message first, then referenced message (same as lm -v)
                    let attachment_to_process = if !msg.attachments.is_empty() {
                        println!("[MAIN] Found {} attachments in current message", msg.attachments.len());
                        Some(&msg.attachments[0])
                    } else if let Some(referenced_msg) = &msg.referenced_message {
                        println!("[MAIN] No local attachments, checking referenced message...");
                        if !referenced_msg.attachments.is_empty() {
                            println!("[MAIN] Found {} attachments in referenced message", referenced_msg.attachments.len());
                            Some(&referenced_msg.attachments[0])
                        } else {
                            println!("[MAIN] No attachments found in referenced message");
                            None
                        }
                    } else {
                        println!("[MAIN] No attachments found and no referenced message");
                        None
                    };

                    let attachment = match attachment_to_process {
                        Some(att) => att,
                        None => {
                            println!("[MAIN] No image attachments found in current or referenced message");
                            let _ = msg.reply(&ctx, "Please attach an image for vision analysis, or reply to a message with an image attachment.").await;
                            return;
                        }
                    };

                    let content_type = attachment.content_type.as_deref().unwrap_or("");
                    println!("[MAIN] Found attachment: {} (content_type: {})", attachment.filename, content_type);

                    if !content_type.starts_with("image/") {
                        println!("[MAIN] Attachment is not an image, returning error");
                        let _ = msg.reply(&ctx, "Attached file is not an image. Please attach a valid image file.").await;
                        return;
                    }

                    println!("[MAIN] Calling vis::handle_vision_request...");
                    if let Err(e) = crate::vis::handle_vision_request(&ctx, &msg, &vision_prompt, attachment).await {
                        println!("[MAIN] Vision request failed with error: {}", e);
                        let _ = msg.reply(&ctx, format!("Vision analysis error: {}", e)).await;
                    } else {
                        println!("[MAIN] Vision request completed successfully");
                    }
                } else {
                    // Add context for regular direct mentions
                    let direct_input = format!(
                        "CONTEXT: The user {} is asking you a direct question (not about a specific message).\n\n\
                        USER'S QUESTION:\n\
                        \"{}\"\n\n\
                        Please respond to {}'s question directly.",
                        msg.author.name,
                        prompt,
                        msg.author.name
                    );
                    
                    if let Err(e) = lm::handle_lm_request(&ctx, &msg, &direct_input).await {
                        println!("[MAIN] Direct user ID mention request failed: {}", e);
                        let _ = msg.reply(&ctx, format!("LM error: {}", e)).await;
                    }
                }
            }
        }
    }
}

// Function to read configuration from botconfig.txt with multi-path fallback
fn load_bot_config() -> Result<HashMap<String, String>, String> {
    let config_paths = [
        "botconfig.txt",
        "../botconfig.txt", 
        "../../botconfig.txt",
        "src/botconfig.txt"
    ];
    
    // Clear any existing relevant environment variables
    env::remove_var("DISCORD_TOKEN");
    env::remove_var("PREFIX");
    env::remove_var("RUST_LOG");
    
    for config_path in &config_paths {
        match fs::read_to_string(config_path) {
            Ok(content) => {
                // Remove BOM if present
                let content = content.strip_prefix('\u{feff}').unwrap_or(&content);
                let mut config = HashMap::new();
                
                // Parse the config file line by line
                for line in content.lines() {
                    let line = line.trim();
                    
                    // Skip empty lines and comments
                    if line.is_empty() || line.starts_with('#') {
                        continue;
                    }
                    
                    // Parse KEY=VALUE format
                    if let Some(equals_pos) = line.find('=') {
                        let key = line[..equals_pos].trim().to_string();
                        let value = line[equals_pos + 1..].trim().to_string();
                        
                        // Set environment variable for compatibility
                        env::set_var(&key, &value);
                        config.insert(key, value);
                    }
                }
                
                println!("✅ Configuration loaded from {}", config_path);
                return Ok(config);
            }
            Err(_) => {
                // Try next path
                continue;
            }
        }
    }
    
    Err("No botconfig.txt file found in any expected location (., .., ../.., src/)".to_string())
}

#[tokio::main]
async fn main() {
    // Initialize logger - must be done before any logging calls
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("error"))
        .format_timestamp_secs()
        .init();
    
    // log::info!("🚀 Meri Bot starting up...");
    
    // Load configuration from botconfig.txt file
    match load_bot_config() {
        Ok(_) => {
            // log::info!("✅ Configuration loaded from botconfig.txt");
            println!("✅ Configuration loaded from botconfig.txt");
        },
        Err(error) => {
            log::error!("❌ Failed to load botconfig.txt: {}", error);
            eprintln!("❌ Failed to load botconfig.txt: {}", error);
            eprintln!("Create a botconfig.txt file in the project root with: DISCORD_TOKEN=your_token_here and PREFIX=^");
            return;
        }
    };
    
    // Get Discord token from configuration
    let token = match env::var("DISCORD_TOKEN") {
        Ok(token) => {
            // Validate token is not placeholder
            if token == "YOUR_BOT_TOKEN_HERE" || token.is_empty() {
                log::error!("❌ DISCORD_TOKEN in botconfig.txt is set to placeholder value");
                eprintln!("❌ DISCORD_TOKEN in botconfig.txt is set to placeholder! Replace with your actual Discord bot token.");
                return;
            }
            // log::debug!("✅ Discord token validated (length: {} chars)", token.len());
            token
        }
        Err(_) => {
            log::error!("❌ DISCORD_TOKEN not found in botconfig.txt file");
            eprintln!("❌ DISCORD_TOKEN not found in botconfig.txt file!");
            return;
        }
    };
    
    // Get command prefix from configuration
    let prefix = env::var("PREFIX").unwrap_or_else(|_| "^".to_string());
    // log::info!("🤖 Starting bot with prefix: '{}'", prefix);
    println!("🤖 Starting bot with prefix: '{}'", prefix);
    
    // Set up command framework
    // log::debug!("🔧 Setting up command framework with prefix: '{}'", prefix);
    let framework = StandardFramework::new()
        .configure(|c| {
            c.prefix(&prefix)
            .case_insensitivity(true)
            .no_dm_prefix(true)
            .with_whitespace(true)
        })
        .after(|_ctx, msg, command_name, result| Box::pin(async move {
            match result {
                Ok(()) => {
                    // log::info!("✅ Command '{}' executed successfully by user {} ({})", 
                    //           command_name, msg.author.name, msg.author.id);
                },
                Err(e) => {
                    log::error!("❌ Command '{}' failed for user {} ({}): {:?}", 
                               command_name, msg.author.name, msg.author.id, e);
                }
            }
        }))
        .unrecognised_command(|_ctx, msg, unrecognized_command_name| Box::pin(async move {
            // log::warn!("❓ Unrecognized command '{}' attempted by user {} ({})", 
            //           unrecognized_command_name, msg.author.name, msg.author.id);
        }))
        .group(&GENERAL_GROUP);

    // Configure bot intents
    let intents = GatewayIntents::non_privileged()
        | GatewayIntents::MESSAGE_CONTENT;

    // Create and start client
    // log::info!("🔧 Creating Discord client...");
    let mut client = match Client::builder(token, intents)
        .event_handler(Handler)
        .framework(framework)
        .await
    {
        Ok(client) => {
            // log::info!("✅ Discord client created successfully");
            client
        },
        Err(e) => {
            log::error!("❌ Error creating Discord client: {:?}", e);
            eprintln!("❌ Error creating Discord client: {:?}", e);
            eprintln!("Check your token in botconfig.txt file");
            return;
        }
    };

    // Initialize per-user context maps for LM and Reason commands
    {
        // log::debug!("🔧 Initializing context maps...");
        let mut data = client.data.write().await;
        data.insert::<LmContextMap>(HashMap::new());
        data.insert::<ReasonContextMap>(HashMap::new());
        data.insert::<UserProfileMap>(HashMap::new());
        data.insert::<SharedConversationMap>(HashMap::new());
        data.insert::<UserRelationshipMap>(HashMap::new());
        data.insert::<UserConversationHistoryMap>(HashMap::new());
        // log::debug!("✅ Context maps initialized");
    }

    // Set up graceful shutdown on CTRL+C
    // log::info!("🚀 Bot is running... Press Ctrl+C to stop");
    println!("🚀 Bot is running... Press Ctrl+C to stop");
    tokio::select! {
        _ = signal::ctrl_c() => {
            // log::info!("📡 Received SIGINT, stopping bot gracefully...");
            println!("\n⏹️ Stopping bot gracefully...");
        }
        result = client.start() => {
            if let Err(why) = result {
                log::error!("❌ Client error: {:?}", why);
                eprintln!("❌ Client error: {:?}", why);
            }
        }
    }
    
    // log::info!("👋 Bot shutdown complete");
    
    println!("✅ Bot stopped");
}
