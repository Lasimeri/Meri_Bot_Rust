// Meri Bot - A Discord bot with AI capabilities, terminal management, and context persistence
// Main entry point for the bot application

// ============================================================================
// MODULE DECLARATIONS
// ============================================================================

mod commands;           // All command modules (see src/commands/)
mod terminal;           // External command execution and system management
mod terminal_manager;   // Terminal output management and prompt handling

// ============================================================================
// IMPORTS
// ============================================================================

// Discord bot framework imports
use serenity::{
    async_trait,
    client::{Client, Context, EventHandler},
    framework::standard::{StandardFramework, Args, Delimiter},
    model::gateway::Ready,
    model::channel::Message,
    model::id::UserId,
    model::application::interaction::Interaction,
    prelude::GatewayIntents,
    prelude::TypeMapKey,
};

// Standard library imports
use std::{
    env,                    // Environment variable management
    fs,                     // File system operations
    collections::HashMap,   // Hash map for data storage
    path::Path,             // Path handling
    io::Write,              // I/O writing operations
};

// Async runtime imports
use tokio::{
    signal,               // Signal handling (Ctrl+C, etc.)
    sync::mpsc,           // Multi-producer, single-consumer channels
    io::{self, AsyncBufReadExt, BufReader}, // Async I/O operations

};

// Serialization and time imports
use serde::{Serialize, Deserialize}; // Serialization for data persistence
use chrono::{DateTime, Utc};         // Date/time handling

// Local imports
use crate::commands::search::ChatMessage;  // Chat message structure for context
use crate::terminal_manager::{TerminalManager, TerminalEvent, get_terminal_manager, set_terminal_manager};

// Command imports (auto-generated by Serenity)
// Commands are auto-registered by the #[command] macro

// Slash command imports
use crate::commands::slash::{handle_slash_command, register_slash_commands};

// ============================================================================
// DATA STRUCTURES
// ============================================================================

/// Enhanced context structure with 50/50 balance and persistence
/// This maintains conversation history for each user with automatic balancing
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserContext {
    pub user_messages: Vec<ChatMessage>,      // Messages sent by the user
    pub assistant_messages: Vec<ChatMessage>, // Messages sent by the bot
    pub last_updated: DateTime<Utc>,          // Timestamp of last interaction
    pub total_interactions: usize,            // Total number of interactions
}

impl UserContext {
    /// Create a new empty user context
    pub fn new() -> Self {
        Self {
            user_messages: Vec::new(),
            assistant_messages: Vec::new(),
            last_updated: Utc::now(),
            total_interactions: 0,
        }
    }

    /// Add a user message to the context and maintain balance
    pub fn add_user_message(&mut self, message: ChatMessage) {
        // Check if we're about to exceed the limit
        if self.user_messages.len() >= 250 {
            println!("[CONTEXT] User context full ({} messages), removing oldest user message", self.user_messages.len());
            self.user_messages.remove(0); // Remove the oldest message
        }
        
        self.user_messages.push(message);
        self.last_updated = Utc::now();
        self.total_interactions += 1;
        
        println!("[CONTEXT] Added user message. Total: {} user, {} assistant messages", 
            self.user_messages.len(), self.assistant_messages.len());
    }

    /// Add an assistant message to the context and maintain balance
    pub fn add_assistant_message(&mut self, message: ChatMessage) {
        // Check if we're about to exceed the limit
        if self.assistant_messages.len() >= 250 {
            println!("[CONTEXT] Assistant context full ({} messages), removing oldest assistant message", self.assistant_messages.len());
            self.assistant_messages.remove(0); // Remove the oldest message
        }
        
        self.assistant_messages.push(message);
        self.last_updated = Utc::now();
        
        println!("[CONTEXT] Added assistant message. Total: {} user, {} assistant messages", 
            self.user_messages.len(), self.assistant_messages.len());
    }

    /// Get all conversation messages in chronological order
    /// This interleaves user and assistant messages for proper context
    pub fn get_conversation_messages(&self) -> Vec<ChatMessage> {
        let mut messages = Vec::new();
        let user_len = self.user_messages.len();
        let assistant_len = self.assistant_messages.len();
        let max_len = std::cmp::max(user_len, assistant_len);

        for i in 0..max_len {
            if i < user_len {
                messages.push(self.user_messages[i].clone());
            }
            if i < assistant_len {
                messages.push(self.assistant_messages[i].clone());
            }
        }

        messages
    }

    /// Maintain 50/50 balance between user and assistant messages
    /// This prevents context from becoming too one-sided
    fn maintain_balance(&mut self) {
        // Keep only the last 250 messages of each type
        if self.user_messages.len() > 250 {
            let removed = self.user_messages.len() - 250;
            println!("[CONTEXT] Removing {} oldest user messages to maintain balance", removed);
            self.user_messages.drain(0..removed);
        }
        if self.assistant_messages.len() > 250 {
            let removed = self.assistant_messages.len() - 250;
            println!("[CONTEXT] Removing {} oldest assistant messages to maintain balance", removed);
            self.assistant_messages.drain(0..removed);
        }
    }

    /// Check if context is getting too large and needs cleanup
    pub fn needs_cleanup(&self) -> bool {
        self.user_messages.len() > 225 || self.assistant_messages.len() > 225
    }

    /// Get context size information for debugging
    pub fn get_context_info(&self) -> String {
        format!("User: {} messages, Assistant: {} messages, Total: {} messages", 
            self.user_messages.len(), self.assistant_messages.len(), self.total_messages())
    }

    /// Clear all conversation history
    pub fn clear(&mut self) {
        self.user_messages.clear();
        self.assistant_messages.clear();
        self.last_updated = Utc::now();
    }

    /// Get total number of messages in context
    pub fn total_messages(&self) -> usize {
        self.user_messages.len() + self.assistant_messages.len()
    }

    /// Force cleanup of context to ensure it stays within limits
    /// This is a safety method to prevent context overflow
    pub fn force_cleanup(&mut self) {
        let user_removed = if self.user_messages.len() > 250 {
            let removed = self.user_messages.len() - 250;
            println!("[CONTEXT] Force cleanup: Removing {} oldest user messages", removed);
            self.user_messages.drain(0..removed);
            removed
        } else {
            0
        };
        
        let assistant_removed = if self.assistant_messages.len() > 250 {
            let removed = self.assistant_messages.len() - 250;
            println!("[CONTEXT] Force cleanup: Removing {} oldest assistant messages", removed);
            self.assistant_messages.drain(0..removed);
            removed
        } else {
            0
        };
        
        if user_removed > 0 || assistant_removed > 0 {
            println!("[CONTEXT] Force cleanup completed: removed {} user, {} assistant messages", user_removed, assistant_removed);
        }
    }
}

// ============================================================================
// TYPEMAP KEYS
// ============================================================================

/// TypeMap key for LM chat context - stores conversation history for language model
pub struct LmContextMap;
impl TypeMapKey for LmContextMap {
    type Value = HashMap<UserId, UserContext>;
}

/// TypeMap key for Reason chat context - stores conversation history for reasoning
pub struct ReasonContextMap;
impl TypeMapKey for ReasonContextMap {
    type Value = HashMap<UserId, UserContext>;
}

/// TypeMap key for storing user conversation histories to enable context-aware queries about other users' conversations
pub struct UserConversationHistoryMap;
impl TypeMapKey for UserConversationHistoryMap {
    type Value = HashMap<UserId, Vec<ChatMessage>>;
}

/// TypeMap key for global LM chat context - stores conversation history shared across all users
/// Used when the bot is mentioned (not for ^lm command)
pub struct GlobalLmContextMap;
impl TypeMapKey for GlobalLmContextMap {
    type Value = UserContext;
}

// ============================================================================
// COMMAND GROUP
// ============================================================================

// Commands are auto-registered by the #[command] macro

// ============================================================================
// TEXT FILE PROCESSING HELPERS
// ============================================================================

/// Read a text file into a String, removing BOM if present
/// Returns Ok(String) or Err(String) with error message
fn read_text_file(path: &str) -> Result<String, String> {
    match fs::read_to_string(path) {
        Ok(content) => {
            // Remove BOM if present (Windows text file encoding)
            let content = content.strip_prefix('\u{feff}').unwrap_or(&content);
            Ok(content.to_string())
        },
        Err(e) => Err(format!("Failed to read file '{}': {}", path, e)),
    }
}

// ============================================================================
// CONFIGURATION MANAGEMENT
// ============================================================================

/// Load bot configuration from botconfig.txt file with multi-path fallback
/// This searches multiple locations for the configuration file
fn load_bot_config() -> Result<HashMap<String, String>, String> {
    let config_paths = [
        "botconfig.txt",           // Current directory
        "../botconfig.txt",        // Parent directory
        "../../botconfig.txt",     // Grandparent directory
        "src/botconfig.txt"        // Source directory
    ];
    
    // Clear any existing relevant environment variables
    env::remove_var("DISCORD_TOKEN");
    env::remove_var("PREFIX");
    env::remove_var("RUST_LOG");
    
    // Try each possible config file location
    for config_path in &config_paths {
        match read_text_file(config_path) {
            Ok(content) => {
                let mut config = HashMap::new();
                // Parse the config file line by line
                for line in content.lines() {
                    let line = line.trim();
                    // Skip empty lines and comments
                    if line.is_empty() || line.starts_with('#') {
                        continue;
                    }
                    // Parse KEY=VALUE format
                    if let Some(equals_pos) = line.find('=') {
                        let key = line[..equals_pos].trim().to_string();
                        let value = line[equals_pos + 1..].trim().to_string();
                        // Set environment variable for compatibility
                        env::set_var(&key, &value);
                        config.insert(key, value);
                    }
                }
                println!("Configuration loaded from {}", config_path);
                return Ok(config);
            }
            Err(_) => {
                // Try next path
                continue;
            }
        }
    }
    Err("No botconfig.txt file found in any expected location (., .., ../.., src/)".to_string())
}

/// Validate Discord token from configuration and log details
fn validate_discord_token() -> Result<String, String> {
    match env::var("DISCORD_TOKEN") {
        Ok(token) => {
            let trimmed = token.trim();
            // Log partial token for debugging (never full token)
            if trimmed.len() >= 12 {
                log::info!("Using Discord token: {}...{} ({} chars)", &trimmed[..6], &trimmed[trimmed.len()-6..], trimmed.len());
            } else {
                log::info!("Using Discord token: {} ({} chars)", trimmed, trimmed.len());
            }
            // Warn if token is surrounded by quotes or whitespace
            if token != trimmed {
                log::warn!("Discord token has leading/trailing whitespace or quotes. It will be trimmed.");
            }
            // Validate token is not placeholder
            if trimmed == "YOUR_BOT_TOKEN_HERE" || trimmed.is_empty() {
                log::error!("DISCORD_TOKEN in botconfig.txt is set to placeholder value or is empty");
                return Err("DISCORD_TOKEN in botconfig.txt is set to placeholder value or is empty".to_string());
            }
            Ok(trimmed.to_string())
        }
        Err(_) => {
            log::error!("DISCORD_TOKEN not found in botconfig.txt file");
            Err("DISCORD_TOKEN not found in botconfig.txt file".to_string())
        }
    }
}

// ============================================================================
// CONTEXT PERSISTENCE
// ============================================================================

/// Save all user contexts to disk for persistence across bot restarts
pub async fn save_contexts_to_disk(
    lm_contexts: &HashMap<UserId, UserContext>,
    reason_contexts: &HashMap<UserId, UserContext>,
    global_lm_context: &UserContext,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    // Create contexts directory if it doesn't exist
    let contexts_dir = Path::new("contexts");
    if !contexts_dir.exists() {
        std::fs::create_dir_all(contexts_dir)?;
    }

    // Save LM contexts (language model conversation history)
    let lm_file = contexts_dir.join("lm_contexts.json");
    let lm_json = serde_json::to_string_pretty(lm_contexts)?;
    let mut lm_file_handle = std::fs::File::create(&lm_file)?;
    lm_file_handle.write_all(lm_json.as_bytes())?;

    // Save Reason contexts (reasoning conversation history)
    let reason_file = contexts_dir.join("reason_contexts.json");
    let reason_json = serde_json::to_string_pretty(reason_contexts)?;
    let mut reason_file_handle = std::fs::File::create(&reason_file)?;
    reason_file_handle.write_all(reason_json.as_bytes())?;

    // Save global LM context (shared across all users)
    let global_lm_file = contexts_dir.join("global_lm_context.json");
    let global_lm_json = serde_json::to_string_pretty(global_lm_context)?;
    let mut global_lm_file_handle = std::fs::File::create(&global_lm_file)?;
    global_lm_file_handle.write_all(global_lm_json.as_bytes())?;

    println!("Saved {} LM contexts, {} Reason contexts, and 1 global LM context to disk", 
        lm_contexts.len(), reason_contexts.len());
    Ok(())
}

/// Load all user contexts from disk on bot startup
pub async fn load_contexts_from_disk() -> Result<(HashMap<UserId, UserContext>, HashMap<UserId, UserContext>, UserContext), Box<dyn std::error::Error + Send + Sync>> {
    let contexts_dir = Path::new("contexts");
    
    // Load LM contexts (language model conversation history)
    let lm_file = contexts_dir.join("lm_contexts.json");
    let lm_contexts = if lm_file.exists() {
        let lm_content = std::fs::read_to_string(&lm_file)?;
        serde_json::from_str::<HashMap<UserId, UserContext>>(&lm_content)?
    } else {
        HashMap::new()
    };

    // Load Reason contexts (reasoning conversation history)
    let reason_file = contexts_dir.join("reason_contexts.json");
    let reason_contexts = if reason_file.exists() {
        let reason_content = std::fs::read_to_string(&reason_file)?;
        serde_json::from_str::<HashMap<UserId, UserContext>>(&reason_content)?
    } else {
        HashMap::new()
    };

    // Load global LM context (shared across all users)
    let global_lm_file = contexts_dir.join("global_lm_context.json");
    let global_lm_context = if global_lm_file.exists() {
        let global_lm_content = std::fs::read_to_string(&global_lm_file)?;
        serde_json::from_str::<UserContext>(&global_lm_content)?
    } else {
        UserContext::new()
    };

    println!("Loaded {} LM contexts, {} Reason contexts, and 1 global LM context from disk", 
        lm_contexts.len(), reason_contexts.len());
    
    Ok((lm_contexts, reason_contexts, global_lm_context))
}

// ============================================================================
// GLOBAL STATE
// ============================================================================

use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Mutex;


/// Global flag to track if the bot has successfully connected to Discord
static BOT_CONNECTED: AtomicBool = AtomicBool::new(false);

/// Global terminal child process - can be None if no window is open
static TERMINAL_CHILD: Mutex<Option<tokio::process::Child>> = Mutex::new(None);

// ============================================================================
// DISCORD EVENT HANDLER
// ============================================================================

/// Event handler implementation - handles Discord events
struct Handler;

#[async_trait]
impl EventHandler for Handler {
    /// Called when the bot successfully connects to Discord
    async fn ready(&self, _: Context, ready: Ready) {
        println!("Bot connected as {}!", ready.user.name);
        
        // Generate and display invite link
        let bot_user_id = env::var("BOT_USER_ID").unwrap_or_else(|_| "1385309017881968761".to_string());
        let application_id = bot_user_id.split('.').next().unwrap_or(&bot_user_id);
        let invite_link = format!("https://discord.com/api/oauth2/authorize?client_id={}&permissions=274877910016&scope=bot", application_id);
        
        println!("🎉 Bot is ready! Invite link:");
        println!("🔗 {}", invite_link);
        println!("📋 Copy this link to invite the bot to your server");
        println!();
        
        // Also send to terminal manager if available
        if let Some(manager) = get_terminal_manager() {
            manager.send_output("🎉 Bot is ready! Invite link:".to_string()).await;
            manager.send_output(format!("🔗 {}", invite_link)).await;
            manager.send_output("📋 Copy this link to invite the bot to your server".to_string()).await;
            manager.send_output("".to_string()).await;
        }
    }

    /// Handle incoming Discord messages
    /// This is the main message processing logic for the bot
    async fn message(&self, ctx: Context, msg: Message) {
        // Check if this is a user mention (like <@bot_id>)
        let bot_user_id = env::var("BOT_USER_ID").unwrap_or_else(|_| "1385309017881968761".to_string());
        let is_mentioned_by_id = msg.content.contains(&format!("<@{}>", bot_user_id));
        
        // Check if this message is a reply to a bot message
        if let Some(referenced_message) = &msg.referenced_message {
            if referenced_message.author.id.to_string() == bot_user_id {
                // This is a reply to a bot message, ignore it
                return;
            }
        }
        
        // Handle user mentions (for global context)
        if is_mentioned_by_id {
            handle_user_mention(&ctx, &msg, &bot_user_id).await;
        }
        
        // For prefix commands, let the StandardFramework handle them
        // The StandardFramework will automatically process commands like ^lm, ^reason, etc.
        // We don't need to do anything here for prefix commands
    }

    /// Handle Discord interactions (slash commands, buttons, etc.)
    async fn interaction_create(&self, ctx: Context, interaction: Interaction) {
        match interaction {
            Interaction::ApplicationCommand(command_interaction) => {
                // Handle slash commands
                if let Err(e) = handle_slash_command(&ctx, &command_interaction).await {
                    eprintln!("Error handling slash command: {}", e);
                    
                    // Try to send an error message to the user
                    if let Err(_) = command_interaction
                        .create_interaction_response(&ctx.http, |response| {
                            response
                                .kind(serenity::model::application::interaction::InteractionResponseType::ChannelMessageWithSource)
                                .interaction_response_data(|message| {
                                    message.content("❌ An error occurred while processing your command. Please try again.")
                                })
                        })
                        .await
                    {
                        eprintln!("Failed to send error message for slash command");
                    }
                }
            }
            _ => {
                // Handle other interaction types if needed
            }
        }
    }
}

/// Handle user ID mentions - functions as ^lm command but with global context
async fn handle_user_mention(ctx: &Context, msg: &Message, bot_user_id: &str) {
    // Log the mention
    log_mention(msg, bot_user_id);
            
    // Extract the prompt after removing the user ID mention
    let prompt = msg.content
        .replace(&format!("<@{}>", bot_user_id), "")
        .trim()
        .to_string();
    
    // Check for special flags that need to be handled by the regular lm command
    if prompt.starts_with("-s ") || prompt.starts_with("--search ") || 
       prompt.starts_with("--test") || prompt == "-t" ||
       prompt.starts_with("--clear") || prompt == "-c" ||
       prompt.starts_with("--clear-global") || prompt == "-cg" {
        // For search, test, and clear commands, use the regular lm command
        // These don't need global context
        let args = Args::new(&prompt, &[Delimiter::Single(' ')]);
        if let Err(e) = crate::commands::lm::lm(ctx, msg, args).await {
            log_error("User mention request failed", &e);
            let _ = msg.reply(ctx, format!("LM error: {}", e)).await;
        } else {
            log_success("User mention request completed successfully");
        }
    } else {
        // For regular chat, vision, and other features, use global context
        if let Err(e) = crate::commands::lm::handle_lm_request_global(ctx, msg, &prompt, Some(&prompt)).await {
            log_error("Global user mention request failed", &e);
            let _ = msg.reply(ctx, format!("LM error: {}", e)).await;
        } else {
            log_success("Global user mention request completed successfully");
        }
    }
}

// ============================================================================
// LOGGING HELPERS
// ============================================================================

/// Log a user mention
fn log_mention(msg: &Message, _bot_user_id: &str) {
    let content = msg.content.clone();
                        if let Some(manager) = get_terminal_manager() {
        tokio::spawn(async move {
            manager.send_output(format!("[MAIN] Bot mentioned via user ID - Raw message content: '{}'", content)).await;
        });
                        } else {
        println!("[MAIN] Bot mentioned via user ID - Raw message content: '{}'", content);
    }
}



/// Log an error
fn log_error(context: &str, error: &dyn std::fmt::Display) {
    let context = context.to_string();
    let error_msg = error.to_string();
    if let Some(manager) = get_terminal_manager() {
        tokio::spawn(async move {
            manager.send_output(format!("[MAIN] {}: {}", context, error_msg)).await;
        });
    } else {
        println!("[MAIN] {}: {}", context, error_msg);
    }
}

/// Log a success message
fn log_success(message: &str) {
    let message = message.to_string();
    if let Some(manager) = get_terminal_manager() {
        tokio::spawn(async move {
            manager.send_output(format!("[MAIN] {}", message)).await;
        });
    } else {
        println!("[MAIN] {}", message);
    }
}

// ============================================================================
// COMMAND LINE INTERFACE
// ============================================================================

/// Handle the command line interface for graceful shutdown and system commands
/// This runs concurrently with the Discord bot and provides local terminal access
async fn handle_command_line(shutdown_tx: mpsc::Sender<String>, event_rx: mpsc::Receiver<TerminalEvent>) {
    use tokio::io::AsyncWriteExt;
    use tokio::time::{sleep, Duration};
    
    let mut event_rx = event_rx;
    let stdin = io::stdin();
    let mut reader = BufReader::new(stdin).lines();
    let mut stdout = io::stdout();
    
    // Wait for bot to connect and show connection messages before showing prompt
    sleep(Duration::from_millis(1500)).await;
    
    // Set prompt as visible and show initial prompt
    if let Some(manager) = get_terminal_manager() {
        *manager.prompt_visible.lock().unwrap() = true;
        manager.show_prompt().await;
        
        // Display initial prompt
        let prompt_text = manager.get_prompt_text();
        if let Err(_) = stdout.write_all(prompt_text.as_bytes()).await {
            eprintln!("Failed to display prompt");
        }
        if let Err(_) = stdout.flush().await {
            eprintln!("Failed to flush stdout");
        }
    }
    
    // Main command processing loop
    loop {
        tokio::select! {
            // Handle terminal events (bot output, prompt management)
            event = event_rx.recv() => {
                handle_terminal_event(event, &mut stdout).await;
            }
            
            // Handle user input
            input = reader.next_line() => {
                if let Ok(Some(line)) = input {
                    let command = line.trim();
                    
                    // Hide prompt before processing command
                    hide_prompt(&mut stdout).await;
                    
                    // Process user commands
                    if let Err(_) = process_user_command(command, &shutdown_tx).await {
                        break;
                    }
                    
                    // Show prompt again after command processing
                    show_prompt(&mut stdout).await;
                } else {
                    // EOF or error reached
                    break;
                }
            }
        }
    }
}

/// Handle terminal events
async fn handle_terminal_event(event: Option<TerminalEvent>, stdout: &mut tokio::io::Stdout) {
    
    match event {
        Some(TerminalEvent::BotOutput(output)) => {
            // Hide current prompt if visible
            hide_prompt(stdout).await;
                        
                        // Print bot output
                        println!("{}", output);
                        
            // Show prompt again after output
            show_prompt(stdout).await;
                    }
                    Some(TerminalEvent::ShowPrompt) => {
            show_prompt(stdout).await;
                    }
                    Some(TerminalEvent::HidePrompt) => {
            hide_prompt(stdout).await;
        }
        Some(TerminalEvent::UpdatePrompt(new_prompt)) => {
            // Update the prompt text in the manager
                        if let Some(manager) = get_terminal_manager() {
                *manager.prompt_text.lock().unwrap() = new_prompt;
                        }
                    }
                    None => {
                        // Channel closed, exit
                    }
                }
            }
            
/// Show the command prompt
async fn show_prompt(stdout: &mut tokio::io::Stdout) {
    use tokio::io::AsyncWriteExt;
    
    if let Some(manager) = get_terminal_manager() {
        let prompt_text = manager.get_prompt_text();
        if let Err(_) = stdout.write_all(prompt_text.as_bytes()).await {
            eprintln!("Failed to display prompt");
        }
        if let Err(_) = stdout.flush().await {
            eprintln!("Failed to flush stdout");
        }
        *manager.prompt_visible.lock().unwrap() = true;
    }
}

/// Hide the command prompt
async fn hide_prompt(stdout: &mut tokio::io::Stdout) {
    use tokio::io::AsyncWriteExt;
    
                        if let Some(manager) = get_terminal_manager() {
                            if manager.is_prompt_visible() {
            // Clear the current line and hide prompt
                                if let Err(_) = stdout.write_all(b"\r\x1B[K").await {
                                    eprintln!("Failed to clear prompt line");
                                }
                                *manager.prompt_visible.lock().unwrap() = false;
                            }
    }
                        }
                        
/// Process user commands
async fn process_user_command(command: &str, shutdown_tx: &mpsc::Sender<String>) -> Result<(), ()> {
    if command.is_empty() {
        return Ok(());
    }
    match command.to_lowercase().as_str() {
                            "quit" | "q" | "exit" => {
            println!("Shutting down bot...");
                                if let Err(_) = shutdown_tx.send("quit".to_string()).await {
                eprintln!("Failed to send shutdown signal");
                                }
            return Err(()); // Signal to break the loop
                            }
                            "help" | "h" => {
            print_help_message();
                            }
                            "status" => {
            print_status_message();
                            }
                            "new" => {
                                if let Err(e) = terminal::create_terminal_session().await {
                eprintln!("Failed to create new terminal session: {}", e);
                                }
                            }
                            "sysinfo" => {
                                if let Err(e) = terminal::get_system_info().await {
                eprintln!("Failed to get system info: {}", e);
                                }
                            }
                            "processes" => {
                                if let Err(e) = terminal::list_processes().await {
                eprintln!("Failed to list processes: {}", e);
                                }
                            }
                            "disk" => {
                                if let Err(e) = terminal::get_disk_space().await {
                eprintln!("Failed to get disk space: {}", e);
                                }
                            }
                            "network" => {
                                if let Err(e) = terminal::get_network_info().await {
                eprintln!("Failed to get network info: {}", e);
                                }
                            }
                            _ => {
            println!("Unknown or unsupported command: '{}'. Type 'help' for available commands.", command);
                            }
    }
    Ok(())
}

/// Print help message
fn print_help_message() {
    println!("Available bot commands:");
    println!("  help, h        - Show this help message");
    println!("  status         - Show bot status");
    println!("  sysinfo        - Get system information");
    println!("  processes      - List running processes");
    println!("  disk           - Get disk space information");
    println!("  network        - Get network information");
    println!("  new            - Open a new command prompt window");
    println!("  exit, quit     - Stop the bot gracefully");
    println!();
    println!("Only the above bot commands are allowed in this window.");
                    }
                    
/// Print status message
fn print_status_message() {
    println!("Bot Status: Running");
    println!("Discord connection: Active");
    println!("Command interface: Active");
            }

// ============================================================================
// CUSTOM LOG WRITER FOR AGENT LOGS
// ============================================================================

struct AgentLogWriter {
    main_log: std::fs::File,
    agent_log: std::fs::File,
}

impl Write for AgentLogWriter {
    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
        // Write to main log
        self.main_log.write_all(buf)?;
        
        // Check if this is an agent log entry
        let log_entry = String::from_utf8_lossy(buf);
        if log_entry.contains("meri_bot_rust::commands::agent") || log_entry.contains("[AGENT]") {
            // Write to agent log file
            self.agent_log.write_all(buf)?;
            self.agent_log.flush()?;
        }
        
        // Flush main log
        self.main_log.flush()?;
        
        Ok(buf.len())
    }
    
    fn flush(&mut self) -> std::io::Result<()> {
        self.main_log.flush()?;
        self.agent_log.flush()?;
        Ok(())
    }
}

// ============================================================================
// MAIN APPLICATION
// ============================================================================

/// Main application entry point
#[tokio::main]
async fn main() {
    // Enable trace logging for agent module, info for everything else
    std::env::set_var("RUST_LOG", "info,meri_bot_rust::commands::agent=trace");
    
    // Create main log file
    let log_file = std::fs::File::create("log.txt").expect("Failed to create log.txt");
    
    // Create agent log file
    let agent_log_file = std::fs::File::create("agentlog.txt").expect("Failed to create agentlog.txt");
    
    // Initialize custom logger that routes agent logs to separate file
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("info"))
        .format_timestamp_secs()
        .format_module_path(true)
        .format_target(true)
        .write_style(env_logger::WriteStyle::Always)
        .target(env_logger::Target::Pipe(Box::new(AgentLogWriter {
            main_log: log_file,
            agent_log: agent_log_file,
        })))
        .init();
    
    log::info!("=== LOGGING SYSTEM INITIALIZED ===");
    log::info!("Log level: INFO (trace logging enabled for agent module)");
    log::info!("Agent module: TRACE level logging enabled");
    log::info!("Main log file: log.txt");
    log::info!("Agent log file: agentlog.txt");
    log::info!("Console logging: ENABLED");
    log::info!("Module path logging: ENABLED");
    log::info!("Target logging: ENABLED");
    
    // Initialize logging to log.txt for lm.rs
    if let Err(e) = crate::commands::lm::init_logging() {
        log::error!("Failed to initialize lm.rs logging: {}", e);
        eprintln!("❌ Failed to initialize lm.rs logging: {}", e);
        // Continue without lm.rs logging rather than exiting
    } else {
        log::info!("✅ lm.rs logging to log.txt initialized successfully");
        println!("✅ lm.rs logging to log.txt initialized successfully");
    }
    
    // Load configuration from botconfig.txt file
    match load_bot_config() {
        Ok(_) => {
            println!("Configuration loaded from botconfig.txt");
        },
        Err(error) => {
            log::error!("Failed to load botconfig.txt: {}", error);
            eprintln!("Failed to load botconfig.txt: {}", error);
            eprintln!("Create a botconfig.txt file in the project root with: DISCORD_TOKEN=your_token_here and PREFIX=^");
            return;
        }
    };
    
    // Get and validate Discord token from configuration
    let token = match validate_discord_token() {
        Ok(token) => token,
        Err(error) => {
            log::error!("{}! Replace with your actual Discord bot token.", error);
            eprintln!("{}! Replace with your actual Discord bot token.", error);
            return;
        }
    };
    
    // Get command prefix from configuration
    let prefix = env::var("PREFIX").unwrap_or_else(|_| "^".to_string());
    println!("Starting bot with prefix: '{}'", prefix);
    
    // Set up command framework for Discord bot
    let framework = create_command_framework(&prefix);

    // Configure bot intents (permissions for Discord API)
    let intents = GatewayIntents::non_privileged()
        | GatewayIntents::MESSAGE_CONTENT; // Required for reading message content

    // Set up graceful shutdown
    let (shutdown_tx, mut shutdown_rx) = mpsc::channel::<String>(1);
    
    // Initialize terminal management system early (but don't open command window yet)
    let (terminal_manager, event_rx) = TerminalManager::new();
    set_terminal_manager(terminal_manager.clone());
    
    // Start the Discord client in the foreground (not a background task)
    println!("Connecting to Discord...");
    log::info!("Starting Discord connection process");
    
    // Log connection attempt details before creating client
    log::info!("Bot token length: {} characters", token.len());
    log::info!("Bot token starts with: {}", &token[..std::cmp::min(10, token.len())]);
    log::info!("Command prefix: '{}'", prefix);
    log::info!("Gateway intents configured: MESSAGE_CONTENT, non_privileged");

    // Create and start Discord client
    log::info!("Creating Discord client with token and intents");
    let mut client = match Client::builder(token.clone(), intents)
        .event_handler(Handler)
        .framework(framework)
        .await
    {
        Ok(client) => {
            log::info!("Discord client created successfully");
            client
        },
        Err(e) => {
            log::error!("Error creating Discord client: {:?}", e);
            eprintln!("Error creating Discord client: {:?}", e);
            eprintln!("Check your token in botconfig.txt file");
            return;
        }
    };

    log::info!("Discord client created, initializing bot data");
    // Initialize context maps and terminal management
    initialize_bot_data(&mut client).await;
    log::info!("Bot data initialized successfully");

    // Register slash commands with Discord
    log::info!("Registering slash commands with Discord");
    if let Err(e) = register_slash_commands(&client.cache_and_http.http).await {
        log::error!("Failed to register slash commands: {}", e);
        eprintln!("Failed to register slash commands: {}", e);
    } else {
        log::info!("Slash commands registered successfully");
        println!("✅ Slash commands registered with Discord");
    }

    // Check for and update restart messages
    check_and_update_restart_messages(&client).await;

    // Now that bot is connected, set up the command line interface
    let (cmd_task, terminal_child) = setup_command_line_interface(shutdown_tx.clone(), event_rx).await;
    
    // Show startup messages
    show_startup_messages().await;

    // Main event loop - wait for shutdown signal or client error
    let shutdown_reason = tokio::select! {
        _ = signal::ctrl_c() => {
            handle_shutdown("SIGINT").await;
            "SIGINT".to_string()
        }
        shutdown_signal = shutdown_rx.recv() => {
            if let Some(signal) = shutdown_signal {
                handle_shutdown(&signal).await;
                signal
            } else {
                "Unknown shutdown".to_string()
            }
        }
        result = client.start() => {
            log::info!("Discord client.start() completed");
            if let Err(why) = result {
                log::error!("Discord client error during connection: {:?}", why);
                eprintln!("Client error: {:?}", why);
                
                // Log specific error details
                let error_str = format!("{:?}", why);
                if error_str.contains("authentication") {
                    log::error!("Authentication error - check if bot token is valid");
                } else if error_str.contains("rate limit") {
                    log::error!("Rate limit error - too many connection attempts");
                } else if error_str.contains("gateway") {
                    log::error!("Gateway error - Discord API issues");
                } else if error_str.contains("network") {
                    log::error!("Network error - check internet connection");
                }
            } else {
                log::info!("Discord client started successfully without errors");
            }
            handle_shutdown("Client task completed").await;
            "Client task completed".to_string()
        }
    };

    // Cleanup and shutdown with context persistence
    println!("Initiating graceful shutdown: {}", shutdown_reason);
    cleanup_and_shutdown(&client, cmd_task, terminal_child).await;
}

/// Create the command framework
fn create_command_framework(prefix: &str) -> StandardFramework {
    StandardFramework::new()
        .configure(|c| {
            c.prefix(prefix)           // Set command prefix
            .case_insensitivity(true)   // Commands are case-insensitive
            .no_dm_prefix(true)         // No prefix needed in DMs
            .with_whitespace(true)      // Allow whitespace in commands
        })
        .after(|_ctx, msg, command_name, result| Box::pin(async move {
            // Post-command execution logging
            match result {
                Ok(()) => {
                    // Command executed successfully
                },
                Err(e) => {
                    log::error!("Command '{}' failed for user {} ({}): {:?}", 
                               command_name, msg.author.name, msg.author.id, e);
                }
            }
        }))
        .unrecognised_command(|_ctx, _msg, _unrecognized_command_name| Box::pin(async move {
            // Handle unrecognized commands (currently silent)
        }))
        // Explicitly register all commands
        .group(&crate::commands::ping::PING_GROUP)
        .group(&crate::commands::echo::ECHO_GROUP)
        .group(&crate::commands::lm::LM_GROUP)
        .group(&crate::commands::reason::REASON_GROUP)
        .group(&crate::commands::agent::AGENT_GROUP)
        .group(&crate::commands::sum::SUM_GROUP)
        .group(&crate::commands::rank::RANK_GROUP)
        .group(&crate::commands::help::HELP_GROUP)
        .group(&crate::commands::admin::ADMIN_GROUP)
}

/// Initialize bot data structures
async fn initialize_bot_data(client: &mut Client) {
        let mut data = client.data.write().await;
        
        // Load existing contexts from disk
        match load_contexts_from_disk().await {
            Ok((lm_contexts, reason_contexts, global_lm_context)) => {
                data.insert::<LmContextMap>(lm_contexts);
                data.insert::<ReasonContextMap>(reason_contexts);
                data.insert::<GlobalLmContextMap>(global_lm_context);
                println!("Context maps initialized with persistent data");
            }
            Err(e) => {
                println!("Failed to load contexts from disk: {}", e);
                println!("Initializing with empty context maps");
                data.insert::<LmContextMap>(HashMap::new());
                data.insert::<ReasonContextMap>(HashMap::new());
                data.insert::<GlobalLmContextMap>(UserContext::new());
            }
        }
        
        data.insert::<UserConversationHistoryMap>(HashMap::new());
}

/// Set up command line interface
async fn setup_command_line_interface(shutdown_tx: mpsc::Sender<String>, event_rx: mpsc::Receiver<TerminalEvent>) -> (tokio::task::JoinHandle<()>, Option<tokio::process::Child>) {
    // Don't automatically open the command prompt window - it's now optional
            println!("Bot is connected and ready!");
        println!("Type 'cmd' to open the command prompt window, or 'help' for available commands");
        println!("Slash commands are now available! Try /help to see all commands.");
    
    // Start a minimal command line handler in background task (for shutdown only)
    let cmd_shutdown_tx = shutdown_tx.clone();
    let cmd_task = tokio::spawn(async move {
        handle_minimal_command_line(cmd_shutdown_tx, event_rx).await;
    });
    (cmd_task, None) // No terminal child initially
}

/// Handle minimal command line interface (shutdown only)
/// This provides a simple way to stop the bot from the main terminal
async fn handle_minimal_command_line(shutdown_tx: mpsc::Sender<String>, event_rx: mpsc::Receiver<TerminalEvent>) {
    use tokio::time::{sleep, Duration};
    
    let mut event_rx = event_rx;
    let stdin = io::stdin();
    let mut reader = BufReader::new(stdin).lines();
    
    // Wait a moment for everything to settle
    sleep(Duration::from_millis(500)).await;
    
    println!("Bot is running and connected to Discord!");
    println!("Type 'cmd' to open the command prompt window");
    println!("Press Ctrl+C or type 'quit' to stop the bot");
    
    // Main command processing loop (minimal - only shutdown commands)
    loop {
    tokio::select! {
            // Handle terminal events (bot output only)
            event = event_rx.recv() => {
                if let Some(TerminalEvent::BotOutput(output)) = event {
                    println!("{}", output);
                }
            }
            
            // Handle user input (only shutdown commands)
            input = reader.next_line() => {
                if let Ok(Some(line)) = input {
                    let command = line.trim().to_lowercase();
                    
                    match command.as_str() {
                        "quit" | "q" | "exit" => {
                            println!("Shutting down bot...");
                            if let Err(_) = shutdown_tx.send("quit".to_string()).await {
                                eprintln!("Failed to send shutdown signal");
                            }
                            // Force exit after sending shutdown signal
                            tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
                            std::process::exit(0);
                        }
                        "cmd" => {
                            println!("Opening command prompt window...");
                            match terminal::create_terminal_session().await {
                                Ok(child) => {
                                    if let Some(child) = child {
                                        // Store the child process globally
                                        if let Ok(mut terminal_guard) = TERMINAL_CHILD.lock() {
                                            *terminal_guard = Some(child);
                                        }
                                        println!("Command prompt window opened successfully!");
                                    } else {
                                        println!("Failed to open command prompt window");
                                    }
                                },
                                Err(e) => {
                                    eprintln!("Failed to open command prompt window: {}", e);
                                }
                            }
                        }
                        "help" | "h" => {
                            println!("Available commands in this terminal:");
                            println!("  cmd            - Open the command prompt window");
                            println!("  quit, q, exit  - Stop the bot gracefully");
                            println!("  help, h        - Show this help message");
                            println!("  status         - Show bot connection status");
                            println!();
                            println!("Use 'cmd' to open a separate command prompt window for system commands");
                        }
                        "status" => {
                            if BOT_CONNECTED.load(Ordering::SeqCst) {
                                println!("Bot Status: Connected to Discord");
            } else {
                                println!("Bot Status: Not connected to Discord");
            }
        }
                        "" => {
                            // Empty line, do nothing
                        }
                        _ => {
                            println!("Unknown command: '{}'. Type 'help' for available commands.", command);
                            println!("Use 'cmd' to open a separate command prompt window for system commands");
                        }
                    }
                } else {
                    // EOF or error reached
                    break;
                }
            }
        }
    }
}

/// Show startup messages
async fn show_startup_messages() {
    // Generate invite link
    let bot_user_id = env::var("BOT_USER_ID").unwrap_or_else(|_| "1385309017881968761".to_string());
    let application_id = bot_user_id.split('.').next().unwrap_or(&bot_user_id);
    let invite_link = format!("https://discord.com/api/oauth2/authorize?client_id={}&permissions=274877910016&scope=bot", application_id);
    
    if let Some(manager) = get_terminal_manager() {
        manager.send_output("Bot is running and connected to Discord!".to_string()).await;
        manager.send_output("🎉 Bot is ready! Invite link:".to_string()).await;
        manager.send_output(format!("🔗 {}", invite_link)).await;
        manager.send_output("📋 Copy this link to invite the bot to your server".to_string()).await;
        manager.send_output("".to_string()).await;
        manager.send_output("Type 'cmd' to open the command prompt window".to_string()).await;
        manager.send_output("Slash commands are now available! Try /help to see all commands.".to_string()).await;
        manager.send_output("Use 'quit' command or press Ctrl+C to stop gracefully".to_string()).await;
    } else {
        println!("Bot is running and connected to Discord!");
        println!("🎉 Bot is ready! Invite link:");
        println!("🔗 {}", invite_link);
        println!("📋 Copy this link to invite the bot to your server");
        println!();
        println!("Type 'cmd' to open the command prompt window");
        println!("Slash commands are now available! Try /help to see all commands.");
        println!("Use 'quit' command or press Ctrl+C to stop gracefully");
    }
}

/// Handle shutdown signals
async fn handle_shutdown(signal: &str) {
    println!("Received '{}' signal, stopping bot gracefully...", signal);
    if let Some(manager) = get_terminal_manager() {
        manager.send_output(format!("Received '{}' signal, stopping bot gracefully...", signal)).await;
    }
    
    // Note: The actual cleanup is handled in the main function after this returns
    // This function just logs the signal and returns to allow proper cleanup
}

/// Check for and update restart messages from previous bot sessions
async fn check_and_update_restart_messages(client: &Client) {
    // Check if restart message file exists
    if let Ok(restart_info) = std::fs::read_to_string("restart_message.txt") {
        let parts: Vec<&str> = restart_info.split('|').collect();
        if parts.len() == 3 {
            if let (Ok(channel_id), Ok(message_id)) = (parts[0].parse::<u64>(), parts[1].parse::<u64>()) {
                let channel_id = serenity::model::id::ChannelId(channel_id);
                let message_id = serenity::model::id::MessageId(message_id);
                
                // Try to update the restart message
                if let Ok(mut message) = channel_id.message(&client.cache_and_http.http, message_id).await {
                    if let Err(e) = message.edit(&client.cache_and_http.http, |m| {
                        m.content("✅ **Bot Successfully Restarted!**\n\nThe bot has been restarted and is now back online.\n\n🟢 **Status**: Connected and ready")
                    }).await {
                        eprintln!("[RESTART] Failed to update restart message: {}", e);
                    } else {
                        println!("[RESTART] Successfully updated restart message");
                    }
                } else {
                    eprintln!("[RESTART] Could not find restart message to update");
                }
            }
        }
        
        // Clean up the restart message file
        if let Err(e) = std::fs::remove_file("restart_message.txt") {
            eprintln!("[RESTART] Failed to remove restart message file: {}", e);
        }
    }
}

/// Cleanup and shutdown the bot
async fn cleanup_and_shutdown(client: &Client, cmd_task: tokio::task::JoinHandle<()>, _terminal_child: Option<tokio::process::Child>) {
    println!("Shutting down bot and closing all windows...");
    
    // Save contexts to disk before shutting down
    // This preserves conversation history across bot restarts
    {
        let data = client.data.read().await;
        let lm_contexts = data.get::<LmContextMap>().cloned().unwrap_or_default();
        let reason_contexts = data.get::<ReasonContextMap>().cloned().unwrap_or_default();
        let global_lm_context = data.get::<GlobalLmContextMap>().cloned().unwrap_or_else(|| crate::UserContext::new());
        
        println!("Saving conversation contexts to disk...");
        println!("  - LM contexts: {} users", lm_contexts.len());
        println!("  - Reason contexts: {} users", reason_contexts.len());
        println!("  - Global LM context: {} total messages", global_lm_context.total_messages());
        
        if let Err(e) = save_contexts_to_disk(&lm_contexts, &reason_contexts, &global_lm_context).await {
            eprintln!("Failed to save contexts to disk: {}", e);
        } else {
            println!("✅ Contexts saved successfully to disk");
        }
    }
    
    // Stop the command line task
    cmd_task.abort();
    
    // Close the command prompt window if it exists (from global state)
    if let Ok(mut terminal_guard) = TERMINAL_CHILD.lock() {
        if let Some(mut child) = terminal_guard.take() {
            println!("Closing command prompt window...");
            if let Err(e) = child.kill().await {
                eprintln!("Failed to kill terminal process: {}", e);
            }
        }
    }
    
    // Also try to close any remaining command prompt windows
    if let Err(e) = terminal::close_bot_command_window().await {
        eprintln!("Failed to close bot command window: {}", e);
    }
    
    // Send final message through terminal manager if available
    if let Some(manager) = get_terminal_manager() {
        manager.send_output("Bot stopped - all windows closed".to_string()).await;
    } else {
        println!("Bot stopped - all windows closed");
    }
    
    println!("Shutdown complete. Goodbye!");
}
